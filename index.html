

<!doctype html>
<html lang="ko">
<head>
<link rel="manifest" href="manifest.json">
<link rel="icon" sizes="192x192" href="assets/logo-192.png">
<link rel="apple-touch-icon" sizes="192x192" href="assets/logo-192.png">
<link rel="icon" sizes="512x512" href="assets/logo-512.png"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>CLUSTRO 시도 - 네비게이션 연동 버전 (v12.1 Enhanced + Navigation)</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
<style>
  :root{
    /* Adjusted theme variables for better contrast and readability */
    --c-primary:#1F3A8A; --c-sky:#0EA5E9; --c-accent:#EA580C; --c-util:#334155;
    --rail-w:64px; --side-w:380px; --gut-w:6px;
    /* increase default font sizes for filter and table for improved readability */
    --flt-font:14px; --tbl-font:14px;
    /* slightly larger marker size */
    --mk:30px;
  }

  /* Mobile-First Responsive Design */
  /* Mobile viewport meta and touch optimization */
  
  /* Base mobile styles for selection panel */
  #selPanel {
    overflow:auto !important; 
    height:auto !important; 
    max-height:none !important;
    /* Enhanced mobile touch interaction */
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  
  /* Mobile-optimized watermark positioning */
  #wm{position:fixed; bottom:8px; right:8px; z-index:9999; background:rgba(255,255,255,0.7); padding:2px 6px; border-radius:4px; font-size:10px; pointer-events:none;}
  
  /* Enhanced mobile/tablet responsive design */
  @media screen and (max-width: 1024px) {
    /* Tablet optimizations */
    #mapControlsTop .btn {
      padding: 10px 14px !important;
      font-size: 15px !important;
      min-height: 42px !important;
    }
    
    #selPanel {
      min-width: 320px !important;
      max-width: calc(100vw - 24px) !important;
      /* Enhanced touch targets for tablet */
      -webkit-tap-highlight-color: transparent;
    }
    
    #selPanel .e-left, #selPanel .e-right { width: 28px !important; }
    #selPanel .e-top, #selPanel .e-bottom { height: 28px !important; }
    #selPanel .e-left { left: -18px !important; }
    #selPanel .e-right { right: -18px !important; }
    #selPanel .e-top { top: -23px !important; }
    #selPanel .e-bottom { bottom: -18px !important; }
  }
  
  @media screen and (max-width: 768px) {
    /* Keep buttons horizontal on mobile for better UX */
    #mapControlsTop {
      flex-direction: row !important;
      flex-wrap: wrap !important;
      gap: 6px !important;
      align-items: center !important;
      padding: 8px !important;
    }
    
    #mapControlsTop .btn {
      flex: 1 1 auto !important;
      min-width: 80px !important;
      padding: 10px 12px !important;
      font-size: 14px !important;
      min-height: 40px !important; /* Enhanced touch target */
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      white-space: nowrap !important;
      border-radius: 8px !important;
      font-weight: 500 !important;
    }
    
    /* Enhanced mobile panel positioning */
    #selPanel {
      right: 12px !important;
      bottom: 70px !important;
      min-width: 280px !important;
      max-width: calc(100vw - 24px) !important;
      min-height: 180px !important;
      max-height: calc(100vh - 140px) !important;
      border-radius: 16px !important;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12) !important;
    }
    
    /* Extra large touch targets for mobile */
    #selPanel .e-left, #selPanel .e-right { width: 35px !important; }
    #selPanel .e-top, #selPanel .e-bottom { height: 35px !important; }
    #selPanel .e-left { left: -22px !important; }
    #selPanel .e-right { right: -22px !important; }
    #selPanel .e-top { top: -27px !important; }
    #selPanel .e-bottom { bottom: -22px !important; }
    
    /* Mobile-optimized panel header */
    #selPanel .head {
      padding: 16px 20px !important;
      min-height: 56px !important;
      border-radius: 16px 16px 0 0 !important;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%) !important;
    }
    
    #selPanel .head h4 {
      font-size: 17px !important;
      line-height: 1.3 !important;
      font-weight: 600 !important;
    }
    
    /* Enhanced mobile buttons */
    #selPanel .btn {
      padding: 10px 16px !important;
      font-size: 15px !important;
      min-height: 44px !important;
      border-radius: 10px !important;
      font-weight: 500 !important;
      transition: all 0.2s ease !important;
    }
    
    #selPanel .btn:active {
      transform: scale(0.98) !important;
      opacity: 0.8 !important;
    }
    
    /* Enhanced table scrolling for mobile */
    #selPanel table {
      font-size: 14px !important;
    }
    
    #selPanel th, #selPanel td {
      padding: 12px 8px !important;
      min-height: 44px !important;
    }
  }
  
  /* Ultra-mobile (small phones) */
  @media screen and (max-width: 480px) {
    #selPanel {
      right: 8px !important;
      bottom: 60px !important;
      min-width: 260px !important;
      max-width: calc(100vw - 16px) !important;
    }
    
    #selPanel .head {
      padding: 14px 16px !important;
      min-height: 52px !important;
    }
    
    #selPanel .head h4 {
      font-size: 16px !important;
    }
    
    #selPanel table {
      font-size: 13px !important;
    }
  }
  
  /* Tablet optimizations */
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    #mapControlsTop .btn {
      padding: 10px 14px !important;
      font-size: 15px !important;
      min-height: 42px !important;
    }
    
    #selPanel {
      min-width: 400px !important;
      max-width: calc(100vw - 32px) !important;
    }
  }
  
  /* Touch device optimizations */
  @media (pointer: coarse) {
    /* Increase touch targets for all interactive elements */
    .btn, button, input, select {
      min-height: 44px !important;
      padding: 12px 16px !important;
    }
    
    /* Enhanced resize handle visibility on touch devices */
    #selPanel .e-left::before,
    #selPanel .e-right::before,
    #selPanel .e-top::before,
    #selPanel .e-bottom::before {
      content: '';
      position: absolute;
      background: rgba(59, 130, 246, 0.1);
      border: 2px solid rgba(59, 130, 246, 0.3);
      border-radius: 4px;
    }
    
    #selPanel .e-left::before,
    #selPanel .e-right::before {
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 40px;
      left: 50%;
      margin-left: -3px;
    }
    
    #selPanel .e-top::before,
    #selPanel .e-bottom::before {
      left: 50%;
      transform: translateX(-50%);
      height: 6px;
      width: 40px;
      top: 50%;
      margin-top: -3px;
    }
  }
  *{box-sizing:border-box}
  body{margin:0;font:14px/1.45 300 "Roboto","Apple SD Gothic Neo","Malgun Gothic",system-ui,sans-serif;color:#111;background:#fff}
  #app{display:grid; min-height:100vh;
    grid-template-columns:var(--rail-w) var(--side-w) var(--gut-w) 1fr;
    grid-template-rows:auto 1fr;
    grid-template-areas:"rail toolbar toolbar toolbar" "rail lhs gut rhs";}

  /* toolbar */
  #toolbar{grid-area:toolbar;display:flex;align-items:center;gap:8px;flex-wrap:wrap;padding:8px 10px;border-bottom:1px solid #e5e7eb;background:#fff}
  .small{font-size:12px;color:#6b7280;font-weight:400}
  select,input[type="text"],input[type="file"],input[type="number"],input[type="url"]{padding:7px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff;font-weight:300}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid #e5e7eb;background:#fff;font-weight:700}
  .badge.ok{border-color:#cfe9d5;color:#137333;background:#f3fbf5}
  .badge.warn{border-color:#f6e4b3;color:#b08900;background:#fff9e6}
  .badge.bad{border-color:#f3c5c5;color:#c92a2a;background:#fff2f2}
  .btn{padding:7px 12px;border-radius:10px;cursor:pointer;border:1px solid transparent;font-weight:700;color:#fff}
  .btn-primary{background:var(--c-primary);border-color:var(--c-primary)}
  .btn-sky{background:var(--c-sky);border-color:var(--c-sky)}
  .btn-accent{background:var(--c-accent);border-color:var(--c-accent)}
  .btn-util{background:var(--c-util);border-color:var(--c-util)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn:hover{filter:brightness(.98)}

  /* left rail */
  #rail{grid-area:rail;border-right:1px solid #e5e7eb;background:#fff;display:flex;flex-direction:column;align-items:center;padding:8px 6px;gap:8px}
  .logo-box{width:56px;height:56px;padding:4px;border-radius:14px;border:1px solid #e5e7eb;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .logo-box svg{width:48px;height:48px;display:block}
  .icbtn{width:56px;border:1px solid #e5e7eb;border-radius:14px;background:#fff;display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;cursor:pointer;transition:.15s}
  .icbtn svg{width:22px;height:22px;stroke:#111;fill:none;stroke-width:2}
  .icbtn span{font-size:11px;font-weight:700;color:#111}
  .icbtn.active{background:var(--c-sky);border-color:var(--c-sky)}
  .icbtn.active svg,.icbtn.active span{stroke:#fff;color:#fff}
  .icbtn:hover{box-shadow:0 2px 10px rgba(0,0,0,.06)}

  /* lhs */
  #lhs{grid-area:lhs;border-right:1px solid #e5e7eb;background:#fff;overflow:auto;font-size:var(--flt-font)}
  details{border-bottom:1px dashed #e5e7eb}
  summary{list-style:none;cursor:pointer;padding:14px 12px;font-weight:700;display:flex;align-items:center;justify-content:space-between}
  details[open] summary{border-bottom:1px dashed #eef2f7}
  .card{padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row>*{flex:1 1 auto}
  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:6px;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;padding:4px 8px;color:#111}

  /* switches */
  .switch{position:relative;display:inline-block;width:48px;height:26px}
  .switch input{display:none}
  .slider{position:absolute;inset:0;background:#e5e7eb;border:1px solid #d1d5db;border-radius:999px;transition:.2s}
  .slider:before{content:"";position:absolute;width:22px;height:22px;left:2px;top:1px;background:#fff;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,.2);transition:.2s}
  .switch input:checked + .slider{background:var(--c-sky);border-color:var(--c-sky)}
  .switch input:checked + .slider:before{transform:translateX(22px)}

  /* gut */
  #gut{grid-area:gut;background:#f3f4f6;cursor:col-resize}

  /* map */
  #rhs{grid-area:rhs;position:relative;background:#fafafa}
  #map{position:absolute;inset:0}

  /* map bottom toolbar */
  .map-bottom{position:absolute;right:16px;bottom:16px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;z-index:6500}
  .toolbar-map{position:static;display:flex;gap:8px;flex-wrap:wrap;z-index:6500}
  .wm{pointer-events:none;user-select:none;font:700 14px/1 "Roboto",sans-serif;color:#fff;-webkit-text-stroke:0.8px #000;text-shadow:0 0 1px rgba(0,0,0,.6)}

  /* panel */
  .panel{position:absolute;right:16px;bottom:90px;width:min(640px,60vw);max-width:80vw;max-height:56vh;overflow:auto;background:#fff;border:1px solid #cbd5e1;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.08);z-index:6000;display:none;min-width:360px;min-height:220px}
  .panel .head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:2px solid #cbd5e1;background:#f8fafc;cursor:move;user-select:none}
  .panel .head h4{margin:0;font-size:13px;font-weight:700}
  .panel .edge{position:absolute;background:transparent}
  .panel .e-left{left:-16px;top:0;width:22px;height:100%;cursor:ew-resize}
  .panel .e-right{right:-16px;top:0;width:22px;height:100%;cursor:ew-resize}
  .panel .e-top{top:-20px;left:0;width:100%;height:24px;cursor:ns-resize}
  .panel .e-bottom{bottom:-16px;left:0;width:100%;height:22px;cursor:ns-resize}
  .panel.dragging .edge{pointer-events:none;opacity:0}
  .panel.resizing .head{pointer-events:none;cursor:default}

  table{width:100%;border-collapse:collapse;font-size:var(--tbl-font);border:1px solid #cbd5e1}
  thead th{position:sticky;top:0;background:#f1f5f9;border-bottom:2px solid #cbd5e1;padding:7px 8px;font-weight:700;border-right:1px solid #e2e8f0}
  tbody td{border-bottom:1px solid #e2e8f0;border-right:1px solid #e2e8f0;padding:6px 8px;font-weight:400;background:#fff}
  tbody tr:hover{background:#f8fafc}
  .row-actions{text-align:center;width:42px}
  .btn-del{cursor:pointer}
  th.has-resizer{position:relative}
  .th-resizer{position:absolute;top:0;right:-3px;width:6px;height:100%;cursor:col-resize}

  /* markers */
  .mk{display:flex;align-items:center;justify-content:center;font-weight:800;line-height:1;transform-origin:center}
  .mk-circle{width:var(--mk);height:var(--mk);border-radius:50%;border:2px solid #000;background:#fff;color:#000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-tag{padding:4px 8px;border-radius:6px;background:#000;color:#fff;border:2px solid #000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-bubble{position:relative;padding:4px 8px 6px 8px;border-radius:6px;background:#fff;color:#000;border:2px solid #000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-bubble i{position:absolute;left:50%;transform:translateX(-50%);bottom:-7px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:8px solid #000}
  .mk-bubble.sel{background:#DC2626;color:#fff;border-color:#DC2626}
  .mk-bubble.sel i{border-top-color:#DC2626}
  .mk.hover{transform:scale(1.12)}

  .mbar{position:absolute;left:72px;top:12px;z-index:6500;display:flex;gap:6px;pointer-events:auto}

  .bw #map{filter:grayscale(100%) contrast(105%)}
  body.dark{background:#0b1220;color:#e5e7eb}
  body.dark #toolbar, body.dark #lhs, body.dark .panel{background:#0f172a;color:#e5e7eb}
  body.dark #lhs, body.dark .panel{border-color:#1f2937}
  body.dark details{border-color:#1f2937}
  body.dark summary{color:#e5e7eb}
  body.dark .card{background:#0f172a}
  body.dark select, body.dark input[type="text"], body.dark input[type="file"], body.dark input[type="number"]{background:#0b1220;color:#e5e7eb;border-color:#334155}
  body.dark .chip{background:#0b1322;border-color:#243041;color:#e5e7eb}
  body.dark .panel .head{background:#0b1322;border-bottom-color:#243041}
  body.dark table{background:#0f172a;border-color:#243041}
  body.dark thead th{background:#0b1322;border-bottom-color:#243041;border-right-color:#243041}
  body.dark tbody td{background:#0f172a;border-right-color:#243041;border-bottom-color:#243041}
  body.dark #rail{background:#0f172a;border-color:#1f2937}
  body.dark .icbtn{background:#0f172a;border-color:#243041}
  body.dark .icbtn svg{stroke:#e5e7eb}
  body.dark .icbtn span{color:#e5e7eb}
  body.dark .badge{background:#111827;border-color:#374151;color:#E5E7EB}
  body.dark .badge.ok{background:#0f1a14;border-color:#1a3c2a;color:#8bf0b2}
  body.dark .badge.warn{background:#2a2310;border-color:#4b3a0e;color:#ffd36a}
  body.dark .badge.bad{background:#2a1212;border-color:#4b1e1e;color:#ff9e9e}
</style>
<link id="leaflet-css" rel="stylesheet" href="assets/leaflet.css">
</head>
<body>
<div id="app">
  <!-- rail -->
  <aside id="rail">
    <div class="logo-box" title="CLUSTRO">
      <!-- crisp SVG logo -->
      <svg viewBox="0 0 64 64" aria-label="CLUSTRO logo">
        <defs>
          <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="#0EA5E9"/>
            <stop offset="1" stop-color="#1F3A8A"/>
          </linearGradient>
        </defs>
        <circle cx="32" cy="32" r="28" fill="url(#g)" stroke="#0b2540" stroke-width="2"/>
        <circle cx="22" cy="22" r="4" fill="#fff"/>
        <circle cx="42" cy="22" r="4" fill="#fff"/>
        <circle cx="22" cy="42" r="4" fill="#fff"/>
        <circle cx="42" cy="42" r="4" fill="#fff"/>
        <path d="M22 22 L42 42 M42 22 L22 42" stroke="#fff" stroke-width="2"/>
      </svg>
    </div>
    <div class="icbtn" data-target="#secData"  title="데이터" aria-label="데이터">
      <svg viewBox="0 0 24 24"><path d="M3 7h18M3 12h18M3 17h18"/><circle cx="7" cy="7" r="1"/><circle cx="11" cy="12" r="1"/><circle cx="15" cy="17" r="1"/></svg>
      <span>데이터</span>
    </div>
    <div class="icbtn" data-target="#secFilter" title="필터" aria-label="필터">
      <svg viewBox="0 0 24 24"><path d="M3 5h18l-7 8v5l-4 2v-7z"/></svg>
      <span>필터</span>
    </div>
    <div class="icbtn" data-target="#secMap"    title="지도" aria-label="지도">
      <svg viewBox="0 0 24 24"><path d="M3 6l7-3 7 3 4-2v16l-7 3-7-3-4 2V6zM10 3v16M17 6v15M3 6v14"/></svg>
      <span>지도</span>
    </div>
    <div class="icbtn" data-target="#secRoute"  title="경로" aria-label="경로">
      <svg viewBox="0 0 24 24"><path d="M4 6h6l2 4h8M4 18h10l2-4h4"/></svg>
      <span>경로</span>
    </div>
    <div class="icbtn" data-target="#secPrint"  title="출력" aria-label="출력">
      <svg viewBox="0 0 24 24"><path d="M6 9V3h12v6M6 14h12v7H6z"/><rect x="3" y="9" width="18" height="7" rx="2"/></svg>
      <span>출력</span>
    </div>
    
    <!-- 다크모드 체크박스를 좌측 아이콘 밑으로 이동 -->
    <label class="chip" style="font-size:10px;user-select:none;padding:4px 6px;margin-top:8px"><input type="checkbox" id="darkToggle" style="margin-right:4px"> 다크모드</label>
    
    <div style="margin-top:auto;font-size:11px;color:#9ca3af">v12.1</div>
  </aside>

  <!-- toolbar -->
  <div id="toolbar">
    <!-- hide font/marker adjustment buttons from the top toolbar; they will be recreated in the settings section -->
    <button class="btn btn-sky" id="btnTblUp" style="display:none">표 폰트 +</button>
    <button class="btn btn-sky" id="btnTblDn" style="display:none">표 폰트 -</button>
    <button class="btn btn-sky" id="btnFltUp" style="display:none">필터 폰트 +</button>
    <button class="btn btn-sky" id="btnFltDn" style="display:none">필터 폰트 -</button>
    <button class="btn btn-sky" id="btnMkUp" style="display:none">마커 +</button>
    <button class="btn btn-sky" id="btnMkDn" style="display:none">마커 -</button>

    <!-- 숨김 처리된 필터/표 포인트 +/- 버튼 (사용하지 않음) -->
    <button class="btn btn-util" id="btnFilterAll" style="display:none">필터 포인트 +</button>
    <button class="btn btn-util" id="btnFilterNone" style="display:none">필터 포인트 -</button>
    <button class="btn btn-util" id="btnSelFromFiltered" style="display:none">표 포인트 +</button>
    <button class="btn btn-util" id="btnSelClearTop" style="display:none">표 포인트 -</button>

    <span class="small" style="margin-left:8px">라벨</span>
    <select id="labelSrc">
      <option value="id">고유번호(C)</option>
      <option value="addr">구분주소(B)</option>
      <option value="name">시설명(G)</option>
    </select>

    <span class="small" style="margin-left:8px">배경</span>
    <select id="baseSelect">
      <option value="auto">자동(OSM→VWorld)</option>
      <option value="osm">OSM</option>
      <option value="vworld_gray">VWorld 회색</option>
      <option value="vworld_base" selected>VWorld 기본</option>
      <option value="none">없음</option>
    </select>

    <span class="small" style="margin-left:8px">줌</span>
    <input type="range" id="zoomRange" min="5" max="19" step="0.1" value="12" style="width:160px">
    <span id="zoomVal" class="badge">12.0</span>

    <!-- 스케일 프리셋 버튼을 숨김 처리 -->
    <div>
      <button class="btn btn-sky scale" data-m="100" style="display:none">100m</button>
      <button class="btn btn-sky scale" data-m="250" style="display:none">250m</button>
      <button class="btn btn-sky scale" data-m="500" style="display:none">500m</button>
      <button class="btn btn-sky scale" data-m="1000" style="display:none">1km</button>
      <button class="btn btn-sky scale" data-m="2000" style="display:none">2km</button>
    </div>

    <div style="display:flex;gap:6px;align-items:center">
      <select id="routeMethod">
        <option value="nn2opt" selected>빠른(최근점+2-opt)</option>
        <option value="nn">최근점</option>
        <!-- 추가 알고리즘 옵션 -->
        <option value="cluster">클러스터(지오그리드·Morton+NN)</option>
        <option value="hilbert">힐버트(Hilbert)</option>
        <option value="kmeans">K‑평균(k-means)</option>
      </select>
      
      <!-- 엔진선택 드롭다운 밑에 배치하기 위해 별도 영역으로 분리 -->
      <div style="margin-top:8px;display:flex;align-items:center;flex-wrap:wrap;gap:6px">
        <label class="small">하루 최대 포인트</label>
        <input type="number" id="dailyMax" value="50" min="1" max="999" style="width:84px">
        <button class="btn btn-primary" id="btnRoute" style="padding:6px 12px;font-size:12px">경로 계산</button>
        <button class="btn btn-util" id="btnRouteClear" style="padding:6px 12px;font-size:12px">초기화</button>
      </div>
      <!-- 데이터 로드 버튼을 숨김 처리 -->
      <button class="btn btn-util" id="btnSelLoad" style="display:none">데이터 로드</button>
      <input type="file" id="selFile" accept=".xlsx,.tsv,.csv" style="display:none">
    </div>

    <!-- 상단 지도 컨트롤: 선택목록/맞춤/필터적용 -->
    <div id="mapControlsTop" style="display:flex;gap:6px;align-items:center">
      <button class="btn btn-sky" id="btnToggleSelTop" title="선택목록">선택목록</button>
      <button class="btn btn-sky" id="btnFitTop" title="맞춤">맞춤</button>
      <button class="btn btn-sky" id="btnRefreshTop" title="필터적용">필터적용</button>
    </div>

    <div style="margin-left:auto;display:flex;gap:6px;align-items:center">
      <span class="badge" id="bTotal">총: 0</span>
      <span class="badge ok" id="bShown">표시: 0</span>
      <span class="badge warn" id="bMissing">좌표없음: 0</span>
      <span class="badge bad" id="bFiltered">필터제외: 0</span>
    </div>
  </div>

  <!-- LHS -->
  <aside id="lhs">
    <section id="secData">
      <details open>
        <summary>데이터 업로드</summary>
        <div class="card">
          <div class="row"><input type="file" id="file" accept=".xlsx,.xls,.xlsm"></div>
          <div class="small">업로드하면 <b>2025DATA</b> 시트의 <b>B,C,G,H,J,R,S,U</b> 열을 자동 사용합니다.<br>
          (구분주소/고유번호/시설명/읍면동/점검일/위도/경도/군집)</div>
          <details id="adv" style="display:none;margin-top:8px">
            <summary>고급 설정 (시트·좌표열 수동)</summary>
            <div class="row">
              <div><label class="small">시트</label><select id="sheet"></select></div>
              <div><button class="btn btn-primary" id="apply">적용</button></div>
            </div>
            <div class="row">
              <div><label class="small">위도 열</label><input id="latCol" placeholder="기본 R"></div>
              <div><label class="small">경도 열</label><input id="lngCol" placeholder="기본 S"></div>
            </div>
          </details>
        </div>
      </details>
    </section>

    <section id="secFilter">
      <details open>
        <summary>필터 · 검색</summary>
        <div class="card">
          <div class="row">
            <input id="searchScope" placeholder="군집 번호 또는 읍면동 이름 (엔터)">
            <button class="btn btn-sky" id="btnClearScope">초기화</button>
          </div>
          <div class="row">
            <label class="chip"><input type="checkbox" id="toggleCoordRelax" checked> 좌표결측 포함(0/누락)</label>
            <label class="chip"><input type="checkbox" id="onlyUninspected" checked> 미점검만(점검일 공란)</label>
          </div>
        </div>

        <div class="card" id="grpBox">
          <div class="row" style="align-items:center">
            <b style="flex:0 0 auto">군집</b>
            <div style="flex:0 0 auto;display:flex;align-items:center;gap:8px">
              <label class="switch"><input type="checkbox" id="grpToggle" checked><span class="slider"></span></label>
              <span class="small" id="grpToggleLbl">전체 선택</span>
            </div>
          </div>
          <div id="grpChips" class="chips" style="margin-top:8px"></div>
        </div>

        <div class="card" id="emdBox">
          <div class="row" style="align-items:center">
            <b style="flex:0 0 auto">읍면동</b>
            <div style="flex:0 0 auto;display:flex;align-items:center;gap:8px">
              <label class="switch"><input type="checkbox" id="emdToggle" checked><span class="slider"></span></label>
              <span class="small" id="emdToggleLbl">전체 선택</span>
            </div>
          </div>
          <div id="emdChips" class="chips" style="margin-top:8px"></div>
        </div>
      </details>
    </section>

    <section id="secMap">
      <details open>
        <summary>지도 설정</summary>
        <div class="card">
          <div class="row">
            <div>
              <label class="small">배경지도</label>
              <select id="basemap">
                <option value="auto">자동</option>
                <option value="vworld-gray">VWorld 회색</option>
                <option value="vworld-base" selected>VWorld 기본</option>
                <option value="osm">OSM</option>
                <option value="none">없음</option>
              </select>
            </div>
            <div>
              <label class="small">마커 스타일</label>
              <select id="markerStyle">
                <option value="circle">원형</option>
                <option value="tag">직사각(블랙)</option>
                <option value="bubble" selected>말풍선(흰/검정)</option>
              </select>
            </div>
          </div>
          <div class="small">자동: OSM → VWorld(회색 → 기본) → 없음</div>
        </div>
      </details>
    </section>

    <section id="secRoute">
      <details open>
        <summary>경로 · 네트워크 거리</summary>
        <div class="card">
          <div class="row">
            <div>
              <label class="small">엔진</label>
              <select id="engine">
                <option value="builtin" selected>내장(최근점+2-opt)</option>
                <option value="osrm">OSRM (무료)</option>
                <option value="cluster">클러스터(지오그리드·Morton+NN)</option>
                <option value="hilbert">힐버트(Hilbert)</option>
                <option value="kmeans">K-평균(k-means)</option>
              </select>
            </div>
            <div>
              <label class="small">OSRM 서버</label>
              <input type="url" id="osrmServer" value="https://router.project-osrm.org">
            </div>
            <div>
              <label class="small">프로필</label>
              <select id="osrmProfile">
                <!-- OSRM 프로필을 한국어로 표기하고 cycling 제거 -->
                <option value="driving" selected>차량</option>
                <option value="walking">도보</option>
              </select>
            </div>
          </div>
          <div class="row">
            <label class="chip"><input type="checkbox" id="autoFill"> 필터 결과 → 선택목록 자동 채움(덮어쓰기)</label>
            <label class="chip"><input type="checkbox" id="fixEnds"> 시작/끝 고정(첫·마지막 유지)</label>
          </div>
          <div class="row">
            <button class="btn btn-sky" id="btnPickAB">지도에서 A/B 선택</button>
            <button class="btn btn-util" id="btnABReset">초기화</button>
            <span class="badge" id="abInfo">A/B: - </span>
            <span class="badge" id="routeStat">거리: - / 시간: -</span>
          </div>
        </div>
      </details>

      <!-- 설정: 자동 재계산 및 경로 외 마커 숨김 토글 (기어 아이콘 제거) -->
      <details open>
        <summary>설정</summary>
        <div class="card">
          <div class="row" style="display:flex;gap:8px;flex-wrap:wrap">
            <label class="chip"><input type="checkbox" id="toggleAutoRecalc" checked> 자동 재계산</label>
            <label class="chip"><input type="checkbox" id="toggleHideNonRoute"> 경로 외 마커 숨김</label>
          </div>
          <div class="row" id="settingsBlock" style="display:flex;gap:6px;flex-wrap:wrap"></div>
        </div>
      </details>
    </section>

    <section id="secPrint">
      <details open>
        <summary>출력</summary>
        <div class="card">
          <div class="row">
            <select id="capMargin">
              <option value="0.5">여백 0.5cm</option>
              <option value="0.7" selected>여백 0.7cm</option>
              <option value="1.0">여백 1.0cm</option>
            </select>
            <select id="capOrient">
              <option value="p" selected>세로</option>
              <option value="l">가로</option>
            </select>
            <select id="capScale">
              <option value="1">품질 1x</option>
              <option value="2" selected>품질 2x</option>
              <option value="3">품질 3x</option>
            </select>
          </div>
          <div class="row" style="margin-top:8px">
            <button class="btn btn-primary" id="btnPDFMap">지도만 PDF</button>
            <button class="btn btn-primary" id="btnPDFScreen">현재화면 캡처 PDF</button>
            <label class="chip"><input type="checkbox" id="toggleBW"> 흑백 인쇄 톤</label>
          </div>
        </div>
      </details>
    </section>

  </aside>

  <div id="gut" title="드래그로 좌측 폭 조절"></div>

  <!-- rhs -->
  <main id="rhs">
    <div class="mbar">
      <button class="btn btn-util" id="btnToggleLeft">좌측 패널</button>
    </div>
    <div id="map"></div>

    <div class="map-bottom">
      <div class="wm" id="wm">© 2025 Hong Seokhyeong</div>
      <div class="toolbar-map" style="display:none">
        <button class="btn btn-sky" id="btnToggleSel">선택목록표</button>
        <button class="btn btn-sky" id="btnFit">표시 영역 맞춤</button>
        <button class="btn btn-sky" id="btnRefresh">필터 적용 구역</button>
      </div>
    </div>

     <!-- 선택목록 패널 -->
    <div class="panel" id="selPanel" aria-label="선택점검목록" style="display:flex; flex-direction:column;">
      <div class="head" title="드래그해서 이동 / 더블클릭 초기 위치">
        <h4>선택점검목록 (더블클릭시 삭제 / 창 드래그·크기조절)</h4>
        <div style="display:flex;gap:6px">
          <button class="btn btn-sky" id="btnClearSel" style="padding:6px 10px;font-size:12px">표 비우기</button>
          <button class="btn btn-sky" id="btnCopyTSV" style="padding:6px 10px;font-size:12px">TSV 복사</button>
          <button class="btn btn-accent"  id="btnSaveXLSX" style="padding:6px 10px;font-size:12px">XLSX 저장</button>
        </div>
      </div>
      <!-- Table container grows with the panel height; overflow scrolls when needed -->
      <div style="flex:1 1 auto; overflow:auto;">
        <table id="selTable">
          <colgroup id="tblCols"><col style="width:150px"><col style="width:220px"><col style="width:260px"><col style="width:90px"><col style="width:46px"></colgroup>
          <thead><tr>
            <th class="has-resizer">고유번호(C)<span class="th-resizer" data-col="0"></span></th>
            <th class="has-resizer">시설명(G)<span class="th-resizer" data-col="1"></span></th>
            <th class="has-resizer">구분주소(B)<span class="th-resizer" data-col="2"></span></th>
            <th class="has-resizer">군집(U)<span class="th-resizer" data-col="3"></span></th>
            <th class="has-resizer">위도<span class="th-resizer" data-col="4"></span></th>
            <th class="has-resizer">경도<span class="th-resizer" data-col="5"></span></th>
            <!-- Add sortable route column with ascending/descending toggle.  Clicking the header will sort by route order -->
            <th class="has-resizer" id="routeHeader">경로 ⇅<span class="th-resizer" data-col="6"></span></th>
            <!-- removed redundant Del header; row deletion handled via per‑row button -->
          </tr></thead>
          <tbody id="selBody"></tbody>
        </table>
      </div>
      <div class="edge e-left"></div>
      <div class="edge e-right"></div>
      <div class="edge e-top"></div>
      <div class="edge e-bottom"></div>
    </div>
  </main>
</div>



<script>
// libs
(async function bootstrap(){
  await loadScriptSeq(()=>window.L, ["assets/leaflet.js"]);
  await loadScriptSeq(()=>window.XLSX, ["assets/xlsx.full.min.js"]);
  await loadScriptSeq(()=>window.html2canvas, ['assets/html2canvas.min.js']);
  await loadScriptSeq(()=>window.jspdf, ['assets/jspdf.umd.min.js']);
  App.init();
})();

async function loadScriptSeq(check, urls){
  for(const url of urls){
    try{
      await new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=url;
        s.onload=res;
        s.onerror=rej;
        document.head.appendChild(s);
      });
      // if the library is now available, bail early
      if(check()) return true;
    }catch(e){
      console.warn('Failed to load script:', url, e);
    }
  }
  // At this point none of the URLs produced a working library.
  // Notify the user so they understand why parts of the interface may not work.
  if(!check()){
    // Construct a more detailed message listing the attempted URLs for easier debugging.
    const names = urls.join(', ');
    alert('필수 라이브러리를 불러오지 못했습니다. 네트워크 연결을 확인하거나 로컬로 번들된 스크립트를 사용해 주세요. 시도한 URL: ' + names);
  }
  return check();
}
</script>

<script>
const App = (function(){
  let wb=null, rows=[], rowsById=new Map();
  let map, groupLayer, routeLayer, baseLayer=null;
  let includeRelax=true, scopeTerm="";
  let tblFont=13, fltFont=13, mk=28;

  const selectedIds=new Set();
  const markersById=new Map();

  let selEmd=new Set();
  let selGrp=new Set();

  let AB=[], abMarkers=[]; // for A/B pick

  // 경로 계산 중인지 여부를 나타내는 플래그. 재귀 호출을 방지하기 위해 사용됩니다.
  let isComputing = false;

  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));
  const setVar=(k,v)=>document.documentElement.style.setProperty(k,v);
  const isBlank=v=>v==null||String(v).trim()===''||String(v).trim().toLowerCase()==='null'||String(v).trim()==='-';
  const A1=a=>a?a.toUpperCase().split('').reduce((n,c)=>n*26+(c.charCodeAt(0)-64),0)-1:-1;

  /* map */
  function setupMap(){
    const KOREA_BOUNDS = L.latLngBounds([33.0,124.0],[39.6,132.5]);
    map = L.map('map',{zoomControl:true, zoomSnap:0.1, zoomDelta:0.1, preferCanvas:true, maxBounds: KOREA_BOUNDS, maxBoundsViscosity: 0.8}).setView([36.635,127.491], 12);
    groupLayer=L.layerGroup().addTo(map);
    routeLayer=L.layerGroup().addTo(map);
    L.control.scale({imperial:false}).addTo(map);

    $('#zoomRange').addEventListener('input', e=>map.setZoom(parseFloat(e.target.value)));
    map.on('zoom', ()=>{const z=map.getZoom().toFixed(1); $('#zoomRange').value=z; $('#zoomVal').textContent=z;});

    $('#baseSelect').value = "vworld_base";
    applyBaseAuto();
  }
  const BASES=[
    {id:'osm',url:'https://tile.openstreetmap.org/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© OpenStreetMap',crossOrigin:true}},
    {id:'vworld_gray',url:'https://xdworld.vworld.kr/2d/gray/202002/service/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© VWorld',crossOrigin:true}},
    {id:'vworld_base',url:'https://xdworld.vworld.kr/2d/Base/service/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© VWorld',crossOrigin:true}},
    {id:'none',url:null,opt:{}}
  ];
  function setNoBase(){ if(baseLayer){map.removeLayer(baseLayer);baseLayer=null;} $('#map').style.background='#f2f2f2'; }
  function tileSample(url){
    const z=Math.round(map.getZoom()), c=map.getCenter();
    const x=Math.floor((c.lng+180)/360*Math.pow(2,z));
    const y=Math.floor((1-Math.log(Math.tan(c.lat*Math.PI/180)+1/Math.cos(c.lat*Math.PI/180))/Math.PI)/2*Math.pow(2,z));
    return url.replace('{z}',z).replace('{x}',x).replace('{y}',y);
  }
  function testTile(url,ms=1600){return new Promise(r=>{if(!url)return r(false);const i=new Image();let done=false;const t=setTimeout(()=>{if(!done){done=true;r(false)}},ms);i.onload=()=>{if(!done){done=true;clearTimeout(t);r(true)}};i.onerror=()=>{if(!done){done=true;clearTimeout(t);r(false)}};i.crossOrigin='anonymous';i.src=tileSample(url);});}
  async function switchBase(id, fallback){
    if(baseLayer){map.removeLayer(baseLayer);baseLayer=null;}
    const cfg=BASES.find(b=>b.id===id)||BASES[0];
    if(!cfg.url){setNoBase();return 'none';}
    const ok=await testTile(cfg.url, 1600);
    if(ok){baseLayer=L.tileLayer(cfg.url,cfg.opt).addTo(map); return cfg.id;}
    if(fallback){
      const order=(cfg.id==='osm')?['vworld_gray','vworld_base','none']:(cfg.id==='vworld_gray')?['vworld_base','none']:(cfg.id==='vworld_base')?['none']:['none'];
      for(const nid of order){ const r=await switchBase(nid,false); if(r) return r; }
    }
    setNoBase(); return 'none';
  }
  async function applyBaseAuto(){
    const v=$('#baseSelect').value;
    if(v==='auto') await switchBase('osm',true);
    else await switchBase(v,false);
  }
  $('#basemap')?.addEventListener('change', e=>{
    const v=e.target.value;
    $('#baseSelect').value = (v==='vworld-gray'?'vworld_gray':v==='vworld-base'?'vworld_base':v);
    applyBaseAuto();
  });
  $('#baseSelect')?.addEventListener('change', applyBaseAuto);

  /* excel */
  function toRows(ws, latCol='R', lngCol='S'){
    const arr=XLSX.utils.sheet_to_json(ws,{header:1,defval:""});
    const B=A1('B'), C=A1('C'), G=A1('G'), H=A1('H'), J=A1('J'), U=A1('U');
    const R=A1(latCol), S=A1(lngCol);
    const out=[];
    for(let i=1;i<arr.length;i++){ const r=arr[i]; if(!r) continue;
      const lat=Number(String(r[R]).replace(/,/g,"")), lng=Number(String(r[S]).replace(/,/g,""));
      out.push({
        id: r[C] ?? i, name: r[G] ?? "", addr: r[B] ?? "",
        grp: r[U] ?? "", emd: r[H] ?? "", date: r[J] ?? "",
        lat: isFinite(lat)?lat:(String(r[R]??"").trim()===""?null:NaN),
        lng: isFinite(lng)?lng:(String(r[S]??"").trim()===""?null:NaN),
      });
    }
    return out;
  }
  async function readFile(f){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload=e=>{
        try{
          wb=XLSX.read(new Uint8Array(e.target.result),{type:"array"});
          if(wb.SheetNames.includes("2025DATA")){
            rows = toRows(wb.Sheets["2025DATA"]);
            rowsById = new Map(rows.map(r=>[String(r.id), r]));
            afterLoad();
          }else{
            $("#adv").style.display='block';
            $("#sheet").innerHTML=wb.SheetNames.map(n=>`<option>${n}</option>`).join("");
            alert("2025DATA 시트를 찾을 수 없어 ‘고급 설정’을 열었습니다.");
          }
          res();
        }catch(err){alert("엑셀 파싱 실패: "+err.message); rej(err);}
      };
      fr.readAsArrayBuffer(f);
    });
  }
  function toRowsManual(){
    const ws=wb.Sheets[$("#sheet").value]; if(!ws){alert("시트를 선택하세요."); return;}
    rows = toRows(ws, ($("#latCol").value||'R'), ($("#lngCol").value||'S'));
    rowsById = new Map(rows.map(r=>[String(r.id), r]));
    afterLoad();
  }
  function afterLoad(){
    selectedIds.clear(); markersById.clear();
    selEmd=new Set(); selGrp=new Set();
    $("#baseSelect").value="vworld_base"; applyBaseAuto();
    updateBadgesBase(); rebuildFilterBoxes(true); render(true);
  }

  /* search/chips */
  function parseSearch(s){
    const tokens=s.trim().split(/\\s+/).filter(Boolean);
    const emdTokens=tokens.filter(t=>/[가-힣]/.test(t));
    const grpTokens=tokens.filter(t=>/^\\d+$/.test(t));
    return {emdTokens, grpTokens};
  }
  function uniq(a){return [...new Set(a.filter(v=>v!==""&&v!=null))].sort((a,b)=>String(a).localeCompare(String(b),'ko'))}
  function fillChipBox(host, values, name, presetSet){
    host.innerHTML = values.length? values.map(v=>{
      const checked = !presetSet || presetSet.size===0 ? 'checked' : (presetSet.has(String(v))?'checked':'');
      return `<label class="chip"><input type="checkbox" name="${name}" value="${encodeURIComponent(String(v))}" ${checked}> ${String(v)}</label>`;
    }).join("") : `<div class="small">해당 항목 없음</div>`;
  }
  function rebuildFilterBoxes(fromLoad=false){
    const {emdTokens, grpTokens} = parseSearch(scopeTerm);
    const base = rows.filter(r=>{
      const hitEmd = !emdTokens.length || emdTokens.some(t=>String(r.emd||"").includes(t) || String(r.addr||"").includes(t));
      const hitGrp = !grpTokens.length || grpTokens.includes(String(r.grp));
      return hitEmd && hitGrp;
    });
    const emdVals = uniq(base.map(r=>r.emd));
    const grpVals = uniq(base.map(r=>r.grp));
    if(fromLoad || (selEmd.size===0 && selGrp.size===0)){
      selEmd = emdTokens.length ? new Set(emdVals.filter(v=>emdTokens.some(t=>String(v).includes(t))).map(String)) : new Set(emdVals.map(String));
      selGrp = grpTokens.length ? new Set(grpTokens.map(String)) : new Set(grpVals.map(String));
    }else{
      selEmd = new Set(emdVals.filter(v=>selEmd.has(String(v))).map(String));
      if(selEmd.size===0 && emdVals.length) selEmd=new Set(emdVals.map(String));
      selGrp = new Set(grpVals.filter(v=>selGrp.has(String(v))).map(String));
      if(selGrp.size===0 && grpVals.length) selGrp=new Set(grpVals.map(String));
    }
    fillChipBox($('#emdChips'), emdVals, "emd", selEmd);
    fillChipBox($('#grpChips'), grpVals, "grp", selGrp);
    refreshToggleStates();
  }
  function refreshToggleStates(){
    const gi=$$('#grpChips input'); const ei=$$('#emdChips input');
    if(gi.length) $('#grpToggle').checked = gi.every(x=>x.checked);
    if(ei.length) $('#emdToggle').checked = ei.every(x=>x.checked);
    $('#grpToggleLbl').textContent = $('#grpToggle').checked ? '전체 선택' : '전체 해제';
    $('#emdToggleLbl').textContent = $('#emdToggle').checked ? '전체 선택' : '전체 해제';
  }

  /* labels/markers */
  function labelFor(r){
    const s=$("#labelSrc").value;
    if(s==='addr') return r.addr||'';
    if(s==='name') return r.name||'';
    return r.id||'';
  }
  function markerHtml(t){
    const k=$("#markerStyle").value;
    if(k==='tag')    return `<div class="mk mk-tag">${t}</div>`;
    if(k==='bubble') return `<div class="mk mk-bubble"><span>${t}</span><i></i></div>`;
    return `<div class="mk mk-circle">${t}</div>`;
  }
  /* 네비게이션 앱 연동 함수 - 플랫폼 자동 감지 및 앱 실행 */
  function openNav(app, lat, lng, name='목적지') {
    // 목적지 이름 URL 인코딩
    const encodedName = encodeURIComponent(name);
    
    // 플랫폼 감지
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
    const isAndroid = /android/i.test(userAgent);
    
    let url = '';
    let fallbackUrl = '';
    
    switch(app) {
      case 'kakao':
        // 카카오맵 - 웹 폴백 포함
        url = `kakaomap://route?ep=${lat},${lng}&by=car`;
        fallbackUrl = `http://m.map.kakao.com/scheme/route?ep=${lat},${lng}&by=car`;
        break;
        
      case 'naver':
        // 네이버맵
        url = `nmap://route/car?dlat=${lat}&dlng=${lng}&dname=${encodedName}&appname=com.example.webapp`;
        if (isIOS) {
          fallbackUrl = 'https://apps.apple.com/kr/app/naver-map/id311867728';
        } else {
          fallbackUrl = 'https://play.google.com/store/apps/details?id=com.nhn.android.nmap';
        }
        break;
        
      case 'tmap':
        // 티맵 - 플랫폼별 다른 URL 스킴
        if (isIOS) {
          url = `tmap://route?rGoName=${encodedName}&rGoX=${lng}&rGoY=${lat}`;
          fallbackUrl = 'https://apps.apple.com/kr/app/tmap/id431589174';
        } else {
          url = `tmap://route?referrer=com.skt.Tmap&goalx=${lng}&goaly=${lat}&goalname=${encodedName}`;
          fallbackUrl = 'https://play.google.com/store/apps/details?id=com.skt.tmap.ku';
        }
        break;
        
      case 'google':
        // 구글맵 - 웹 기반, 앱 자동 연동
        url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
        break;
        
      case 'apple':
        // 애플맵 - iOS 전용
        if (isIOS) {
          url = `http://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
        } else {
          // Android에서는 구글맵으로 대체
          url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
        }
        break;
        
      default:
        console.error('Unknown navigation app:', app);
        return;
    }
    
    // 앱 실행 시도
    if (app === 'google' || (app === 'apple' && !fallbackUrl)) {
      // 웹 기반 앱은 바로 열기
      window.open(url, '_blank');
    } else if (app === 'kakao') {
      // 카카오맵은 웹 폴백 사용
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
      iframe.src = url;
      
      // 앱이 없으면 웹 버전으로 이동
      setTimeout(() => {
        document.body.removeChild(iframe);
        window.open(fallbackUrl, '_blank');
      }, 1500);
    } else {
      // 기타 네이티브 앱 실행 시도
      const startTime = Date.now();
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
      iframe.src = url;
      
      // 앱이 설치되지 않은 경우 스토어로 이동
      setTimeout(() => {
        const elapsed = Date.now() - startTime;
        document.body.removeChild(iframe);
        
        // 앱이 실행되지 않았다면 스토어로 이동
        if (elapsed < 2000 && fallbackUrl) {
          window.open(fallbackUrl, '_blank');
        }
      }, 1500);
    }
  }
  
  function tooltipHtml(r){return `<div><b>${r.id||''}</b> - ${r.name||''}<br>${r.addr||''} · ${r.emd||''} · ${r.grp||''}</div>`;}
  function popupHtml(r){
    // Popup displays basic info using textContent to avoid HTML injection and includes action buttons.
    // We build a temporary div and assign textContent for each line to mitigate injection risk.
    const wrapper=document.createElement('div'); wrapper.style.fontSize='12px';
    const lines=[
      ['고유번호:', r.id||''],
      ['시설명:',   r.name||''],
      ['구분주소:', r.addr||''],
      ['읍면동:',   (r.emd||'')+ ' · 군집: '+ (r.grp||'')]
    ];
    lines.forEach(([label,value])=>{
      const p=document.createElement('div');
      const b=document.createElement('b'); b.textContent=label;
      const span=document.createElement('span'); span.textContent=' '+value;
      p.appendChild(b); p.appendChild(span);
      wrapper.appendChild(p);
    });
    // 액션 버튼들 - 추가/제거
    const addBtn=document.createElement('button'); addBtn.className='btn btn-sky'; addBtn.setAttribute('data-act','add'); addBtn.textContent='추가';
    const remBtn=document.createElement('button'); remBtn.className='btn btn-accent'; remBtn.setAttribute('data-act','remove'); remBtn.textContent='제거';
    const btnWrap=document.createElement('div'); 
    btnWrap.style.marginTop = '8px';
    btnWrap.appendChild(addBtn); 
    btnWrap.appendChild(document.createTextNode(' ')); 
    btnWrap.appendChild(remBtn);
    wrapper.appendChild(btnWrap);
    
    // 길찾기 버튼들 추가 - 위도/경도가 있는 경우에만
    if(r.lat && r.lng && r.lat !== 0 && r.lng !== 0) {
      const navTitle = document.createElement('div');
      navTitle.style.marginTop = '10px';
      navTitle.style.marginBottom = '4px';
      navTitle.style.fontWeight = 'bold';
      navTitle.textContent = '길찾기:';
      wrapper.appendChild(navTitle);
      
      const navWrap = document.createElement('div');
      navWrap.style.display = 'flex';
      navWrap.style.flexWrap = 'wrap';
      navWrap.style.gap = '4px';
      
      // 네비게이션 앱 버튼들
      const navApps = [
        {id: 'kakao', name: '카카오', color: '#FEE500', textColor: '#000'},
        {id: 'naver', name: '네이버', color: '#03C75A', textColor: '#fff'},
        {id: 'tmap', name: '티맵', color: '#FF0000', textColor: '#fff'},
        {id: 'google', name: '구글', color: '#4285F4', textColor: '#fff'},
        {id: 'apple', name: '애플', color: '#000', textColor: '#fff'}
      ];
      
      navApps.forEach(app => {
        const navBtn = document.createElement('button');
        navBtn.style.padding = '4px 8px';
        navBtn.style.fontSize = '11px';
        navBtn.style.border = 'none';
        navBtn.style.borderRadius = '4px';
        navBtn.style.backgroundColor = app.color;
        navBtn.style.color = app.textColor;
        navBtn.style.cursor = 'pointer';
        navBtn.textContent = app.name;
        navBtn.setAttribute('data-nav', app.id);
        navBtn.setAttribute('data-lat', r.lat);
        navBtn.setAttribute('data-lng', r.lng);
        navBtn.setAttribute('data-name', r.name || r.addr || '목적지');
        navWrap.appendChild(navBtn);
      });
      
      wrapper.appendChild(navWrap);
    }
    return wrapper.outerHTML;
  }

  function applySelectedStyle(id){
    const m=markersById.get(id); if(!m) return;
    const el=m.getElement(); if(!el) return;
    const box=el.firstChild; if(!box) return;
    if(selectedIds.has(id)) box.classList.add('sel'); else box.classList.remove('sel');
  }

  function filtered(){
    const pass = rows.filter(r=>{
      const missing=(r.lat==null||r.lng==null||Number.isNaN(r.lat)||Number.isNaN(r.lng)||r.lat===0||r.lng===0);
      const passCoord = includeRelax || !missing;
      const passGrp = selGrp.size===0 || selGrp.has(String(r.grp));
      const passEmd = selEmd.size===0 || selEmd.has(String(r.emd));
      const passUn  = (!$('#onlyUninspected').checked) || isBlank(r.date);
      return passCoord && passGrp && passEmd && passUn;
    });
    return pass;
  }

  function render(fit){
    groupLayer.clearLayers(); markersById.clear();
    const pts=[];
    for(const r of filtered()){
      if(!isFinite(r.lat) || !isFinite(r.lng) || r.lat===0 || r.lng===0) continue;
      const m=L.marker([r.lat,r.lng],{icon:L.divIcon({html:markerHtml(labelFor(r)),className:"",iconSize:null})});
      m.bindTooltip(tooltipHtml(r),{sticky:true});
      m.bindPopup(popupHtml(r));
      // When the popup opens, wire up the Add/Remove buttons and Navigation buttons.
      m.on('popupopen', e=>{
        const el = e.popup.getElement();
        const addBtn = el.querySelector('[data-act="add"]');
        const remBtn = el.querySelector('[data-act="remove"]');
        if(addBtn) addBtn.onclick = () => {
          // r may be a shallow copy; fetch the canonical record from rowsById if available
          const rec = rowsById.get(String(r.id)) || r;
          addToSel(rec);
          m.closePopup();
        };
        if(remBtn) remBtn.onclick = () => {
          removeFromSel(String(r.id));
          m.closePopup();
        };
        
        // 길찾기 버튼 이벤트 핸들러 추가
        const navBtns = el.querySelectorAll('[data-nav]');
        navBtns.forEach(btn => {
          btn.onclick = () => {
            const app = btn.getAttribute('data-nav');
            const lat = btn.getAttribute('data-lat');
            const lng = btn.getAttribute('data-lng');
            const name = btn.getAttribute('data-name');
            // 네비게이션 함수 호출 - 사용자 액션으로 실행됨
            openNav(app, lat, lng, name);
            m.closePopup();
          };
        });
      });
      m.on('mouseover', ()=>{const el=m.getElement(); if(el) el.firstChild.classList.add('hover');});
      m.on('mouseout',  ()=>{const el=m.getElement(); if(el) el.firstChild.classList.remove('hover');});
      m.addTo(groupLayer); pts.push([r.lat,r.lng]);
      const id=String(r.id); markersById.set(id, m);
      setTimeout(()=>applySelectedStyle(id),0);
    }
    updateBadgesAfter();
    if(fit && pts.length) map.fitBounds(L.latLngBounds(pts).pad(0.2));
  }

  function updateBadgesBase(){
    const t=rows.length, miss=rows.filter(r=>r.lat==null||r.lng==null||Number.isNaN(r.lat)||Number.isNaN(r.lng)||r.lat===0||r.lng===0).length;
    $("#bTotal").textContent=`총: ${t}`; $("#bMissing").textContent=`좌표없음: ${miss}`;
  }
  function updateBadgesAfter(){
    const a=filtered(); const shown=a.filter(r=>isFinite(r.lat)&&isFinite(r.lng)&&r.lat!==0&&r.lng!==0).length;
    $("#bShown").textContent=`표시: ${shown}`; $("#bFiltered").textContent=`필터제외: ${Math.max(0, rows.length - a.length)}`;
  }

  /* selection table */
  function openSel(){ $("#selPanel").style.display='block' }
  function addToSel(r){
    openSel();
    const id=String(r.id);
    if(selectedIds.has(id)) return;
    selectedIds.add(id); applySelectedStyle(id);
    const tr=document.createElement('tr'); tr.draggable=true; tr.dataset.id=id;
    tr.innerHTML=`<td>${r.id||""}</td>
                  <td>${r.name||""}</td>
                  <td>${r.addr||""}</td>
                  <td>${r.grp||""}</td>
                  <td>${isFinite(r.lat)?r.lat:""}</td>
                  <td>${isFinite(r.lng)?r.lng:""}</td>
                  <td><input type="number" class="routeOrder" value="" min="1" style="width:60px"></td>
                  <td class="row-actions">
                    <span class="btn-del">❌</span>
                    ${(r.lat && r.lng && r.lat !== 0 && r.lng !== 0) ? `<span class="btn-nav" data-lat="${r.lat}" data-lng="${r.lng}" data-name="${(r.name || r.addr || '목적지').replace(/"/g, '&quot;')}" title="길찾기">🧭</span>` : ''}
                  </td>`;
    tr.addEventListener('dblclick', ()=>removeRow(tr));
    tr.addEventListener('dragstart', e=>{tr.classList.add('dragging'); e.dataTransfer.setData('text/plain','row');});
    tr.addEventListener('dragend', ()=>tr.classList.remove('dragging'));
    $("#selBody").appendChild(tr);

    // 선택 목록에 추가한 후 일일 최대 포인트 값을 현재 선택된 개수로 갱신하고, 2개 이상일 경우 즉시 경로를 재계산합니다.
    try {
      const rows=document.querySelectorAll('#selBody tr');
      const daily=document.getElementById('dailyMax');
      if(daily){ daily.value = rows.length.toString(); }
      if(rows.length>=2){
        // skip auto-fill during manual addition so existing selections are preserved
        if(!isComputing) computeRoute(true);
      }else{
        // 1개 이하일 때는 기존 경로를 지우고 통계 초기화
        drawRoute([]);
        document.getElementById('routeStat').textContent='거리: - / 시간: -';
      }
    } catch(_){ /* ignore errors */ }
  }

  // Remove a point from the selection table by its id.  This helper searches the
  // table body for a row with a matching data-id attribute and uses removeRow
  // to delete it.  If the id is not found, nothing happens.  After removal
  // computeRoute will be triggered via removeRow.
  function removeFromSel(id){
    const body = document.getElementById('selBody');
    if(!body) return;
    const tr = Array.from(body.querySelectorAll('tr')).find(tr => String(tr.dataset.id) === String(id));
    if(tr) removeRow(tr);
  }
  function removeRow(tr){
    const id=String(tr.dataset.id);
    selectedIds.delete(id);
    applySelectedStyle(id);
    tr.remove();
    // Remaining rows and daily max update
    const remaining = document.querySelectorAll('#selBody tr');
    const daily=document.getElementById('dailyMax');
    if(daily){ daily.value = remaining.length.toString(); }
    // Recompute route if two or more points remain; otherwise clear route and stats
    if(remaining.length >= 2){
      // skip auto-fill during manual removal
      if(!isComputing) computeRoute(true);
    }else{
      drawRoute([]);
      document.getElementById('routeStat').textContent='거리: - / 시간: -';
    }
  }

  // Allow sorting of the selection list by the route order column.  Clicking the
  // route header toggles between ascending and descending numeric order.  After
  // sorting, the route is recomputed (without auto-fill) so the blue polyline
  // remains accurate.
  (function enableRouteSort(){
    const header=document.getElementById('routeHeader');
    if(!header) return;
    let asc=true;
    header.addEventListener('click', ()=>{
      const body=document.getElementById('selBody');
      const rows=Array.from(body.querySelectorAll('tr'));
      rows.sort((a,b)=>{
        const aval=parseInt(a.querySelector('input.routeOrder')?.value||'')||0;
        const bval=parseInt(b.querySelector('input.routeOrder')?.value||'')||0;
        return asc? aval - bval : bval - aval;
      });
      rows.forEach(tr=>body.appendChild(tr));
      asc=!asc;
      // reassign selectedIds order and recompute route without auto-fill
      if(rows.length>=2){
        if(!isComputing) computeRoute(true);
      }
    });
  })();
  $("#selBody").addEventListener('click', e=>{ 
    if(e.target.classList.contains('btn-del')) {
      removeRow(e.target.closest('tr')); 
    } else if(e.target.classList.contains('btn-nav')) {
      // 선택 목록의 길찾기 버튼 클릭 처리 - 드롭다운 메뉴 표시
      const lat = e.target.getAttribute('data-lat');
      const lng = e.target.getAttribute('data-lng');  
      const name = e.target.getAttribute('data-name');
      
      // 기존 드롭다운 제거
      document.querySelectorAll('.nav-dropdown').forEach(el => el.remove());
      
      // 드롭다운 메뉴 생성
      const dropdown = document.createElement('div');
      dropdown.className = 'nav-dropdown';
      dropdown.style.cssText = `
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 10000;
        padding: 4px;
        min-width: 120px;
      `;
      
      const navApps = [
        {id: 'kakao', name: '카카오', color: '#FEE500', textColor: '#000'},
        {id: 'naver', name: '네이버', color: '#03C75A', textColor: '#fff'},
        {id: 'tmap', name: '티맵', color: '#FF0000', textColor: '#fff'},
        {id: 'google', name: '구글', color: '#4285F4', textColor: '#fff'},
        {id: 'apple', name: '애플', color: '#000', textColor: '#fff'}
      ];
      
      navApps.forEach(app => {
        const btn = document.createElement('button');
        btn.style.cssText = `
          display: block;
          width: 100%;
          padding: 6px 8px;
          margin: 2px 0;
          border: none;
          border-radius: 3px;
          background: ${app.color};
          color: ${app.textColor};
          cursor: pointer;
          font-size: 12px;
        `;
        btn.textContent = app.name;
        btn.onclick = () => {
          openNav(app.id, lat, lng, name);
          dropdown.remove();
        };
        dropdown.appendChild(btn);
      });
      
      // 드롭다운 위치 계산
      const rect = e.target.getBoundingClientRect();
      dropdown.style.left = (rect.left - 60) + 'px';
      dropdown.style.top = (rect.bottom + 5) + 'px';
      
      document.body.appendChild(dropdown);
      
      // 외부 클릭시 드롭다운 닫기
      setTimeout(() => {
        document.addEventListener('click', function closeDropdown(evt) {
          if (!dropdown.contains(evt.target)) {
            dropdown.remove();
            document.removeEventListener('click', closeDropdown);
          }
        });
      }, 0);
    }
  });
  $("#selBody").addEventListener('dragover', e=>{
    e.preventDefault();
    const dragging=$("#selBody tr.dragging");
    const elsib=Array.from($("#selBody").querySelectorAll('tr:not(.dragging)'));
    const after=elsib.reduce((best,ch)=>{const b=ch.getBoundingClientRect(); const o=e.clientY-b.top-b.height/2; return (o<0&&o>best.offset)?{offset:o,element:ch}:best;},{offset:-Infinity}).element;
    if(!after) $("#selBody").appendChild(dragging); else $("#selBody").insertBefore(dragging, after);
  });
  (function colResize(){
    const table=$("#selTable"); const cols=$("#tblCols").children;
    let startX,startW,colIdx,drag=false;
    table.addEventListener('mousedown', e=>{
      if(!e.target.classList.contains('th-resizer')) return;
      colIdx=parseInt(e.target.getAttribute('data-col')); if(isNaN(colIdx)) return;
      drag=true; startX=e.clientX; startW=parseInt(cols[colIdx].style.width)||table.tHead.rows[0].cells[colIdx].offsetWidth;
      document.body.style.cursor='col-resize';
      window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
      e.preventDefault();
    });
    function onMove(e){ if(!drag) return; const w=Math.max(60,startW+(e.clientX-startX)); cols[colIdx].style.width=w+'px'; }
    function onUp(){ drag=false; document.body.style.cursor=''; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
  })();

 /* 패널 가장자리 리사이즈 */
  (function edgeResize(){
    const p = $("#selPanel");
    const minW=360, minH=220;
    let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0;
    function start(e, which){
      resizing=true; edge=which; sx=e.clientX; sy=e.clientY; sw=p.offsetWidth; sh=p.offsetHeight;
      document.body.style.cursor = (which==='left'||which==='right')?'ew-resize':'ns-resize';
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);
      e.preventDefault();
    }
    function move(e){
      if(!resizing) return;
      if(edge==='left'){ const dx = sx - e.clientX; p.style.width = Math.max(minW, sw + dx)+'px'; }
      else if(edge==='right'){ const dx = e.clientX - sx; p.style.width = Math.max(minW, sw + dx)+'px'; }
      else if(edge==='top'){ const dy = sy - e.clientY; p.style.height = Math.max(minH, sh + dy)+'px'; }
      else if(edge==='bottom'){ const dy = e.clientY - sy; p.style.height = Math.max(minH, sh + dy)+'px'; }
    }
    function stop(){ resizing=false; edge=''; document.body.style.cursor=''; window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', stop); }
    p.querySelector('.e-left').addEventListener('mousedown', e=>start(e,'left'));
    p.querySelector('.e-right').addEventListener('mousedown', e=>start(e,'right'));
    p.querySelector('.e-top').addEventListener('mousedown', e=>start(e,'top'));
    p.querySelector('.e-bottom').addEventListener('mousedown', e=>start(e,'bottom'));
  })();

  /* 패널 헤더 드래그 이동 + 더블클릭 초기 위치 복원 */
  (function panelDrag(){
    const p = $("#selPanel");
    const head = p.querySelector('.head');
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', e=>{
      dragging=true;
      const r=p.getBoundingClientRect();
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      p.style.left = r.left+'px'; p.style.top = r.top+'px';
      p.style.right=''; p.style.bottom='';
      document.body.style.userSelect='none';
      e.preventDefault();
    });
    window.addEventListener('mousemove', e=>{
      if(!dragging) return;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      p.style.left=(sl+dx)+'px';
      p.style.top =(st+dy)+'px';
    });
    window.addEventListener('mouseup', ()=>{ if(!dragging) return; dragging=false; document.body.style.userSelect=''; });
    head.addEventListener('dblclick', ()=>{ p.style.width=''; p.style.height=''; p.style.left=''; p.style.top=''; p.style.right='16px'; p.style.bottom='90px'; });
  })();


  /* route drawing */
  function getSelectedPoints(){
    const arr=[];
    $$("#selBody tr").forEach(tr=>{
      const t=Array.from(tr.querySelectorAll('td'));
      const id=(t[0]?.innerText||"").trim();
      const lat=parseFloat(t[4]?.innerText||""); const lng=parseFloat(t[5]?.innerText||"");
      if(isFinite(lat)&&isFinite(lng)) arr.push({id,lat,lng});
    });
    return arr;
  }
  function drawRouteLatLngs(latlngs){
    routeLayer.clearLayers();
    if(latlngs.length>=2){
      L.polyline(latlngs,{color:'#1064e8',weight:3,opacity:0.9}).addTo(routeLayer);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }
  }
  function drawRoute(orderIds){
    routeLayer.clearLayers();
    if(!orderIds || orderIds.length<2) return;
    const pts=getSelectedPoints();
    const latlngs=[];
    orderIds.forEach(id=>{
      const pt = pts.find(p=>String(p.id)===String(id));
      if(pt) latlngs.push([pt.lat, pt.lng]);
    });
    drawRouteLatLngs(latlngs);
  }
  /*
   * Compute geodesic distance between two latitude/longitude points using the
   * haversine formula.  Returns the distance in kilometres.  This replaces
   * the previous Euclidean distance approximation (degree squared), which
   * could significantly under‑ or over‑estimate route lengths when points are
   * far apart or near the poles.
   */
  function dist(a,b){
    // Earth radius in kilometres
    const R = 6371;
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);
    const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
    return 2 * R * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
  }
  function nearestNeighbor(points){
    if(points.length===0) return [];
    const left=[...points]; const order=[];
    let cur=left.shift(); order.push(cur);
    while(left.length){
      let bestIdx=0, bestD=Infinity;
      for(let i=0;i<left.length;i++){ const d=dist(cur,left[i]); if(d<bestD){bestD=d; bestIdx=i;} }
      cur=left.splice(bestIdx,1)[0]; order.push(cur);
    }
    return order;
  }
  function twoOpt(order){
    function total(o){ let s=0; for(let i=0;i<o.length-1;i++) s+=dist(o[i],o[i+1]); return s; }
    let improved=true; let best=order.slice(); let bestCost=total(best);
    while(improved){
      improved=false;
      for(let i=1;i<best.length-2;i++){
        for(let k=i+1;k<best.length-1;k++){
          const newOrder = best.slice(0,i).concat(best.slice(i,k+1).reverse(), best.slice(k+1));
          const c=total(newOrder);
          if(c<bestCost){best=newOrder; bestCost=c; improved=true;}
        }
      }
    }
    return best;
  }

  /*
   * Compute Morton (Z‑order) code for a latitude/longitude pair.  The latitude and
   * longitude are normalised to the range [0,1] and quantised to 15 bits before
   * interleaving.  Higher bit depths yield a more detailed ordering but are
   * unnecessary for a modest number of points.
   */
  function mortonCode(lat, lng){
    const latNorm=(lat+90)/180;
    const lngNorm=(lng+180)/360;
    const latInt=Math.min(32767,Math.max(0,Math.floor(latNorm*32767)));
    const lngInt=Math.min(32767,Math.max(0,Math.floor(lngNorm*32767)));
    let code=0;
    for(let i=0;i<15;i++){
      code |= ((lngInt>>i)&1)<<(2*i);
      code |= ((latInt>>i)&1)<<(2*i+1);
    }
    return code;
  }

  /*
   * Cluster engine: returns an ordered array of points by sorting them via their
   * Morton code and then applying nearest neighbour to refine local continuity.
   */
  function clusterOrder(points){
    if(!points || points.length<=2) return points.slice();
    const sorted=points.slice().sort((a,b)=>mortonCode(a.lat,a.lng)-mortonCode(b.lat,b.lng));
    return nearestNeighbor(sorted);
  }

  /*
   * Hilbert order: compute a Hilbert curve index for each point based on normalized lat/lng.
   * This implementation uses a simple bitwise algorithm to map two 16-bit coordinates into a 32-bit Hilbert index.
   */
  function hilbertIndex(x, y, bits=16){
    let rx, ry;
    let index = 0;
    for(let s=bits-1; s>=0; s--){
      rx = (x >> s) & 1;
      ry = (y >> s) & 1;
      index += (1 << (2*s)) * ((3 * rx) ^ ry);
      // rotate
      if(ry === 0){
        if(rx === 1){
          x = (1 << bits) - 1 - x;
          y = (1 << bits) - 1 - y;
        }
        const tmp = x; x = y; y = tmp;
      }
    }
    return index;
  }

  function hilbertOrder(points){
    if(!points || points.length<=2) return points.slice();
    let minLat=Infinity,maxLat=-Infinity,minLng=Infinity,maxLng=-Infinity;
    for(const p of points){ if(p.lat<minLat) minLat=p.lat; if(p.lat>maxLat) maxLat=p.lat; if(p.lng<minLng) minLng=p.lng; if(p.lng>maxLng) maxLng=p.lng; }
    const factor=(1<<16)-1;
    const arr=points.map(p=>{
      const x=Math.floor(((p.lng-minLng)/(maxLng-minLng+1e-9))*factor);
      const y=Math.floor(((p.lat-minLat)/(maxLat-minLat+1e-9))*factor);
      const h=hilbertIndex(x,y,16);
      return {h,id:p.id, lat:p.lat, lng:p.lng};
    });
    arr.sort((a,b)=>a.h-b.h);
    return arr.map(e=>{ return {id:e.id, lat:e.lat, lng:e.lng}; });
  }

  /*
   * k-means order: cluster points into approximately sqrt(n) clusters.
   */
  function kmeansOrder(points){
    const n=points.length;
    if(n<=2) return points.slice();
    const k=Math.max(1, Math.round(Math.sqrt(n)));
    // initialize centers with first k points
    const centers=points.slice(0,k).map(p=>({lat:p.lat,lng:p.lng}));
    let assignments=new Array(n).fill(0);
    for(let iter=0; iter<5; iter++){
      // assign points to nearest center
      for(let i=0;i<n;i++){
        let best=0; let bestDist=Infinity;
        for(let j=0;j<k;j++){
          const d=dist(points[i], centers[j]);
          if(d<bestDist){ bestDist=d; best=j; }
        }
        assignments[i]=best;
      }
      // recompute centers
      const sumLat=new Array(k).fill(0); const sumLng=new Array(k).fill(0); const count=new Array(k).fill(0);
      for(let i=0;i<n;i++){
        const c=assignments[i]; sumLat[c]+=points[i].lat; sumLng[c]+=points[i].lng; count[c]++;
      }
      for(let j=0;j<k;j++){
        if(count[j]>0){ centers[j].lat=sumLat[j]/count[j]; centers[j].lng=sumLng[j]/count[j]; }
      }
    }
    // cluster arrays
    const clusters=Array.from({length:k},()=>[]);
    for(let i=0;i<n;i++) clusters[assignments[i]].push(points[i]);
    // order clusters by nearest neighbour of centers
    const centerOrder=nearestNeighbor(centers);
    const result=[];
    for(const idx of centerOrder){
      const cl=clusters[idx];
      const seq=nearestNeighbor(cl);
      result.push(...seq);
    }
    return result;
  }

  async function computeRoute(skipAutoFill=false){
    // 이미 계산 중이면 중복 호출을 방지합니다
    if(isComputing) return;
    isComputing = true;
    try{
    // optional auto-fill (only when skipAutoFill is false)
    if(!skipAutoFill && $('#autoFill').checked){
      const candidates = filtered().filter(r=>isFinite(r.lat)&&isFinite(r.lng));
      const max = Math.max(1, parseInt($('#dailyMax').value)||999);
      // overwrite
      $("#selBody").innerHTML=''; selectedIds.clear();
      for(const r of candidates.slice(0,max)){ addToSel(r); }
    }

    const pts=getSelectedPoints(); if(pts.length<2){alert("선택목록에 2개 이상이 필요합니다."); return;}
    const engine=$('#engine').value;
    // If using cluster engine, compute order using Morton code + nearest neighbour and draw route directly
    if(engine==='cluster' || engine==='hilbert' || engine==='kmeans'){
      let order=[];
      let label="";
      if(engine==='cluster'){ order = clusterOrder(pts); label='클러스터'; }
      else if(engine==='hilbert'){ order = hilbertOrder(pts); label='힐버트'; }
      else if(engine==='kmeans'){ order = kmeansOrder(pts); label='K-평균'; }
      // write back route numbers to selection table
      const idToIdx=new Map(order.map((p,i)=>[String(p.id), i+1]));
      $$("#selBody tr").forEach(tr=>{
        const id=(tr.querySelector('td')?.innerText||"").trim();
        const inp=tr.querySelector('input.routeOrder'); if(!inp) return;
        inp.value = idToIdx.get(String(id))||"";
      });
      drawRoute(order.map(p=>p.id));
      // compute distance/time using haversine and display with label
      let totalDist=0;
      for(let i=0;i<order.length-1;i++){
        totalDist += dist(order[i], order[i+1]);
      }
      const km=totalDist;
      const avgSpeed=30;
      const minutes = km / avgSpeed * 60;
      $('#routeStat').textContent = `거리: ${km.toFixed(1)}km / 시간: ${minutes.toFixed(0)}분 (${label})`;
      return;
    }

    if(engine==='osrm'){
      try{
        const server=$('#osrmServer').value.replace(/\/+$/,'');
        const profile=$('#osrmProfile').value;
        // Trip API for order
        const coords=pts.map(p=>`${p.lng},${p.lat}`).join(';');
        const roundtrip = $('#fixEnds').checked ? 'false' : 'true';
        const src = $('#fixEnds').checked ? 'first' : 'any';
        const dst = $('#fixEnds').checked ? 'last' : 'any';
        const url=`${server}/trip/v1/${profile}/${coords}?geometries=geojson&overview=full&roundtrip=${roundtrip}&source=${src}&destination=${dst}`;
        const res=await fetch(url);
        if(!res.ok) throw new Error('OSRM 응답 오류');
        const data=await res.json();
        if(!data.trips || !data.trips.length) throw new Error('경로 없음');
        const trip=data.trips[0];
        const orderIds = trip.waypoints.sort((a,b)=>a.waypoint_index-b.waypoint_index).map(wp=>pts[wp.trips_index??wp.waypoint_index]?.id ?? pts[wp.waypoint_index]?.id);
        drawRoute(orderIds);
        const m=(trip.distance||0)/1000; const t=(trip.duration||0)/60;
        $('#routeStat').textContent=`거리: ${m.toFixed(1)}km / 시간: ${t.toFixed(0)}분 (OSRM)`;
        return;
      }catch(e){
        console.warn('OSRM 실패, 내장 폴백 사용', e);
        $('#routeStat').textContent=`OSRM 실패→내장 폴백`;
        // fallthrough to builtin
      }
    }

    // builtin
    const method=$("#routeMethod").value;
    let order=pts;
    if(method==='cluster'){
      order = clusterOrder(pts);
    }else if(method==='hilbert'){
      order = hilbertOrder(pts);
    }else if(method==='kmeans'){
      order = kmeansOrder(pts);
    }else if(method==='nn'){
      order = nearestNeighbor(pts);
    }else{
      // default to nearest neighbour + 2-opt for "빠른" and other unknown values
      order = twoOpt(nearestNeighbor(pts));
    }
    const idToIdx=new Map(order.map((p,i)=>[String(p.id), i+1]));
    $$("#selBody tr").forEach(tr=>{
      const id=(tr.querySelector('td')?.innerText||"").trim();
      const inp=tr.querySelector('input.routeOrder'); if(!inp) return;
      inp.value = idToIdx.get(String(id))||"";
    });
    drawRoute(order.map(p=>p.id));
    /* compute actual distance using haversine and estimate travel time.
       The original implementation simply labelled the result as a Euclidean approximation.
       This version sums the haversine distance between consecutive points to get a more realistic path length.
       Travel time is estimated assuming an average speed of 30 km/h (typical for urban driving) */
    let totalDist=0;
    for(let i=0;i<order.length-1;i++){
      totalDist += dist(order[i], order[i+1]);
    }
    const km = totalDist;
    const avgSpeed = 30; // km/h
    const minutes = km / avgSpeed * 60;
    $('#routeStat').textContent = `거리: ${km.toFixed(1)}km / 시간: ${minutes.toFixed(0)}분 (내장)`;
    } finally {
      isComputing = false;
    }
  }
  // When clicking the route button we want to allow auto-fill if enabled, so call computeRoute with skipAutoFill=false
  $("#btnRoute").addEventListener('click', ()=> computeRoute(false));
  $("#btnRouteClear").addEventListener('click', ()=>{ routeLayer.clearLayers(); $$(".routeOrder").forEach(i=>i.value=""); $('#routeStat').textContent='거리: - / 시간: -'; });

  /* A/B pick */
  function enableAB(on){
    if(on){
      AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[];
      $('#abInfo').textContent='A/B: 지도에서 두 지점을 클릭하세요';
      map.getContainer().style.cursor='crosshair';
      const handler=(e)=>{
        AB.push([e.latlng.lat, e.latlng.lng]);
        const m=L.circleMarker(e.latlng,{radius:8,color:'#EA580C'}).addTo(routeLayer); abMarkers.push(m);
        $('#abInfo').textContent=`A/B: ${AB.length}개 선택`;
        if(AB.length===2){ map.off('click', handler); map.getContainer().style.cursor=''; abRoute(); }
      };
      map.on('click', handler);
      $('#btnABReset').onclick=()=>{ map.off('click', handler); map.getContainer().style.cursor=''; AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[]; $('#abInfo').textContent='A/B: -'; };
    }else{
      AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[]; $('#abInfo').textContent='A/B: -';
    }
  }
  async function abRoute(){
    if(AB.length<2) return;
    const engine=$('#engine').value;
    if(engine==='osrm'){
      try{
        const server=$('#osrmServer').value.replace(/\/+$/,'');
        const profile=$('#osrmProfile').value;
        const coords=[AB[0],AB[1]].map(p=>`${p[1]},${p[0]}`).join(';');
        const url=`${server}/route/v1/${profile}/${coords}?geometries=geojson&overview=full`;
        const res=await fetch(url);
        if(!res.ok) throw new Error('OSRM 응답 오류');
        const data=await res.json();
        const r=data.routes?.[0];
        if(!r) throw new Error('경로 없음');
        drawRouteLatLngs(r.geometry.coordinates.map(c=>[c[1],c[0]]));
        const m=(r.distance||0)/1000; const t=(r.duration||0)/60;
        $('#routeStat').textContent=`거리: ${m.toFixed(1)}km / 시간: ${t.toFixed(0)}분 (A/B OSRM)`;
        return;
      }catch(e){
        console.warn('OSRM A/B 실패', e);
        $('#routeStat').textContent=`OSRM 실패(A/B)`;
      }
    }else{
      // straight line
      drawRouteLatLngs(AB.map(p=>[p[0],p[1]]));
      const R=(a,b)=>Math.sqrt(Math.pow(a[0]-b[0],2)+Math.pow(a[1]-b[1],2))*111; // rough km
      const m=R(AB[0],AB[1]);
      $('#routeStat').textContent=`직선 거리: ~${m.toFixed(1)}km (내장)`;
    }
  }
  $('#btnPickAB').addEventListener('click', ()=>enableAB(true));
  $('#btnABReset').addEventListener('click', ()=>enableAB(false));

  /* panel patch + hover shield */
  (function selPanelPatch(){
    const p = $("#selPanel");
    // edges
    ["left","right","top","bottom"].forEach(k=>{
      const d=document.createElement("div"); d.className="edge e-"+k; p.appendChild(d);
    });
    const head = p.querySelector(".head");
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener("pointerdown", e=>{
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      dragging=true; p.classList.add("dragging");
      const r=p.getBoundingClientRect();
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      p.style.left=r.left+"px"; p.style.top=r.top+"px";
      p.style.right=""; p.style.bottom="";
      p.setPointerCapture(e.pointerId);
    });
    head.addEventListener("pointermove", e=>{
      if(!dragging) return;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      p.style.left=(sl+dx)+"px"; p.style.top =(st+dy)+"px";
    });
    head.addEventListener("pointerup", e=>{
      if(!dragging) return;
      dragging=false; p.classList.remove("dragging");
      try{p.releasePointerCapture(e.pointerId);}catch(_){}
    });
    head.addEventListener("dblclick", ()=>{
      p.style.width=""; p.style.height="";
      p.style.left=""; p.style.top="";
      p.style.right="16px"; p.style.bottom="90px";
    });

    const minW=360, minH=180;
    let resizing=false, eg="", sx2=0, sy2=0, sw=0, sh=0, sl2=0, st2=0;
    function startResize(e, which){
      resizing=true; eg=which; p.classList.add("resizing");
      const r=p.getBoundingClientRect();
      sx2=e.clientX; sy2=e.clientY; sw=r.width; sh=r.height; sl2=r.left; st2=r.top;
      p.style.left=sl2+"px"; p.style.top=st2+"px";
      p.style.right=""; p.style.bottom="";
      p.setPointerCapture(e.pointerId);
      e.preventDefault();
    }
    function doResize(e){
      if(!resizing) return;
      const dx=e.clientX-sx2, dy=e.clientY-sy2;
      if(eg==="right"){ p.style.width=Math.max(minW, sw+dx)+"px"; }
      if(eg==="left"){  const w=Math.max(minW, sw-dx); p.style.width=w+"px"; p.style.left=(sl2+dx)+"px"; }
      if(eg==="bottom"){p.style.height=Math.max(minH, sh+dy)+"px"; }
      if(eg==="top"){   const h=Math.max(minH, sh-dy); p.style.height=h+"px"; p.style.top=(st2+dy)+"px"; }
    }
    function stopResize(e){
      if(!resizing) return;
      resizing=false; eg=""; p.classList.remove("resizing");
      try{p.releasePointerCapture(e.pointerId);}catch(_){}
    }
    p.querySelector(".e-left").addEventListener("pointerdown", ev=>startResize(ev,"left"));
    p.querySelector(".e-right").addEventListener("pointerdown", ev=>startResize(ev,"right"));
    p.querySelector(".e-top").addEventListener("pointerdown", ev=>startResize(ev,"top"));
    p.querySelector(".e-bottom").addEventListener("pointerdown", ev=>startResize(ev,"bottom"));
    p.addEventListener("pointermove", doResize);
    p.addEventListener("pointerup", stopResize);

    // *** CRITICAL: stop map interaction while hovering over panel ***
    function disableMapInteractions(){
      if(!map) return;
      map.dragging.disable(); map.scrollWheelZoom.disable(); map.doubleClickZoom.disable();
      map.touchZoom.disable(); map.boxZoom.disable(); map.keyboard.disable();
      if(L && L.DomEvent){
        L.DomEvent.disableClickPropagation(p);
        L.DomEvent.disableScrollPropagation(p);
      }
    }
    function enableMapInteractions(){
      if(!map) return;
      map.dragging.enable(); map.scrollWheelZoom.enable(); map.doubleClickZoom.enable();
      map.touchZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();
    }
    p.addEventListener('mouseenter', disableMapInteractions);
    p.addEventListener('mouseleave', enableMapInteractions);
  })();

  /* buttons & binds */
  function bind(){
    // rail icon -> open section
    $$("#rail .icbtn").forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.getAttribute('data-target'); const sec = target? document.querySelector(target): null;
        const opened = btn.classList.contains('active');
        $$("#rail .icbtn").forEach(b=>b.classList.remove('active'));
        if(opened){
          setVar('--side-w','0px'); $("#lhs").style.display='none';
        } else{
          setVar('--side-w','380px'); $("#lhs").style.display='block'; btn.classList.add('active');
          if(sec){
            document.querySelectorAll('#lhs section details').forEach(d=>d.open=false);
            sec.querySelector('details').open=true; sec.scrollIntoView({behavior:"smooth",block:"start"});
          }
        }
        setTimeout(()=>map.invalidateSize(),150);
      });
    });

    $("#btnToggleLeft").onclick=()=>{
      const open = getComputedStyle($("#lhs")).display!=='none';
      if(open){ setVar('--side-w','0px'); $("#lhs").style.display='none'; }
      else{ setVar('--side-w','380px'); $("#lhs").style.display='block'; }
      setTimeout(()=>map.invalidateSize(),150);
    };

    // files
    $("#file").addEventListener('change', async e=>{const f=e.target.files[0]; if(!f) return; await readFile(f);});
    $("#apply").addEventListener('click', toRowsManual);

    // search
    function runSearchApply(){ scopeTerm=$("#searchScope").value.trim(); rebuildFilterBoxes(false); render(true); }
    $("#searchScope").addEventListener('keydown', e=>{ if(e.key==="Enter") runSearchApply(); });
    $("#btnClearScope").addEventListener('click', ()=>{ $("#searchScope").value=''; scopeTerm=""; rebuildFilterBoxes(true); render(true); });
    $("#toggleCoordRelax").addEventListener('change', e=>{ includeRelax=e.target.checked; render(true); });
    $("#onlyUninspected").addEventListener('change', ()=>render(true));

    function syncChips(boxId){
      document.querySelector(`#${boxId}`).addEventListener('change', e=>{
        if(e.target.name==='grp' || e.target.name==='emd'){
          const val=decodeURIComponent(e.target.value);
          if(e.target.name==='grp'){ if(e.target.checked) selGrp.add(val); else selGrp.delete(val); }
          else{ if(e.target.checked) selEmd.add(val); else selEmd.delete(val); }
          refreshToggleStates(); render(true);
        }
      });
    }
    syncChips('grpBox'); syncChips('emdBox');

    // chip helpers
    $("#btnFilterAll").addEventListener('click', ()=>{
      const gi=$$('#grpChips input'); const ei=$$('#emdChips input');
      gi.forEach(x=>x.checked=true); ei.forEach(x=>x.checked=true);
      selGrp=new Set(gi.map(x=>decodeURIComponent(x.value)));
      selEmd=new Set(ei.map(x=>decodeURIComponent(x.value)));
      refreshToggleStates(); render(true);
    });
    $("#btnFilterNone").addEventListener('click', ()=>{
      $$('#grpChips input').forEach(x=>x.checked=false); $$('#emdChips input').forEach(x=>x.checked=false);
      selGrp=new Set(); selEmd=new Set(); refreshToggleStates(); render(true);
    });

    // labels/marker style
    $("#labelSrc").addEventListener('change', ()=>render(false));
    $("#markerStyle").addEventListener('change', ()=>render(false));

    // scale shortcuts
    function setScaleMeters(m){
      const center=map.getCenter(); const px=map.getSize().x*(1/3);
      const target=m/px; const zoom=Math.log2(156543.03392*Math.cos(center.lat*Math.PI/180)/target);
      map.setZoom(zoom);
    }
    $$(".scale").forEach(b=>b.addEventListener('click',()=>setScaleMeters(parseInt(b.dataset.m,10)||500)));

    // map toolbar
    $("#btnFit").onclick=()=>{
      const pts=[]; routeLayer.eachLayer(l=>{ if(l.getLatLngs){ try{ pts.push(...l.getLatLngs()); }catch(_){} } });
      if(!pts.length){ groupLayer.eachLayer(l=>{if(l.getLatLng) pts.push(l.getLatLng());}); }
      if(pts.length) map.fitBounds(L.latLngBounds(pts).pad(0.2));
    };
    $("#btnRefresh").onclick=()=>render(true);
    $("#btnToggleSel").onclick=()=>{ 
      const p=$("#selPanel"); 
      const wasHidden = p.style.display !== 'block';
      p.style.display=(p.style.display==='block'?'none':'block');
      
      // 패널을 열 때 화면 중앙으로 위치 조정
      if (wasHidden && p.style.display === 'block') {
        setTimeout(() => centerSelectionPanel(), 100);
      }
    };

    // 상단 지도 컨트롤 버튼: 기존 기능을 호출하도록 바인딩
    if($("#btnFitTop")){
      $("#btnFitTop").addEventListener('click', ()=>{
        // 기존 맞춤 버튼과 동일한 동작 수행
        $("#btnFit").onclick();
      });
    }
    if($("#btnRefreshTop")){
      $("#btnRefreshTop").addEventListener('click', ()=>{
        // 기존 필터 적용 버튼과 동일한 동작 수행
        $("#btnRefresh").onclick();
      });
    }
    if($("#btnToggleSelTop")){
      $("#btnToggleSelTop").addEventListener('click', ()=>{
        // 기존 선택목록 토글과 동일한 동작 수행
        $("#btnToggleSel").onclick();
        // 모바일에서 선택목록을 열 때 화면 중앙으로 위치 조정
        setTimeout(() => {
          const panel = $("#selPanel");
          if (panel && panel.style.display === 'block') {
            centerSelectionPanel();
          }
        }, 100);
      });
    }
    
    // 선택목록 패널을 화면 중앙으로 이동시키는 함수
    function centerSelectionPanel() {
      const panel = $("#selPanel");
      if (!panel) return;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const panelRect = panel.getBoundingClientRect();
      
      // 모바일/태블릿 감지
      const isMobile = viewportWidth <= 768;
      const isTablet = viewportWidth > 768 && viewportWidth <= 1024;
      
      if (isMobile) {
        // 모바일: 화면 중앙, 적절한 크기로 조정
        const idealWidth = Math.min(350, viewportWidth - 32);
        const idealHeight = Math.min(400, viewportHeight - 120);
        
        panel.style.width = idealWidth + 'px';
        panel.style.height = idealHeight + 'px';
        panel.style.left = ((viewportWidth - idealWidth) / 2) + 'px';
        panel.style.top = '80px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else if (isTablet) {
        // 태블릿: 화면 중앙, 더 큰 크기
        const idealWidth = Math.min(500, viewportWidth - 64);
        const idealHeight = Math.min(500, viewportHeight - 120);
        
        panel.style.width = idealWidth + 'px';
        panel.style.height = idealHeight + 'px';
        panel.style.left = ((viewportWidth - idealWidth) / 2) + 'px';
        panel.style.top = '80px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else {
        // 데스크톱: 기본 위치로 복원
        panel.style.width = '640px';
        panel.style.height = '400px';
        panel.style.left = '';
        panel.style.top = '';
        panel.style.right = '16px';
        panel.style.bottom = '90px';
      }
    }

    // selection load
    $("#btnSelLoad").addEventListener('click', ()=>$("#selFile").click());
    $("#selFile").addEventListener('change', async e=>{
      const f=e.target.files[0]; if(!f) return;
      const name=f.name.toLowerCase();
      if(name.endsWith('.xlsx')||name.endsWith('.xlsm')||name.endsWith('.xls')){
        const buf=await f.arrayBuffer();
        const wb2=XLSX.read(new Uint8Array(buf),{type:"array"});
        const ws=wb2.Sheets[wb2.SheetNames[0]];
        const arr=XLSX.utils.sheet_to_json(ws);
        $("#selBody").innerHTML=''; selectedIds.clear();
        for(const r of arr){
          const id = r["고유번호"] ?? r["id"] ?? r["ID"] ?? r["Id"];
          const base = rowsById.get(String(id)) || {};
          addToSel({id:String(id||""), name:r["시설명"]??base.name??"", addr:r["구분주소"]??base.addr??"", grp:r["군집"]??base.grp??"", lat:parseFloat(r["위도"]??base.lat), lng:parseFloat(r["경도"]??base.lng)});
          const last=$("#selBody tr:last-child input.routeOrder"); if(last) last.value = r["경로"]||"";
        }
      }else{
        const txt=await f.text();
        const lines=txt.split(/\\r?\\n/).filter(Boolean);
        const head=lines.shift().split(/\\t|,/);
        const idx=(name)=>head.findIndex(h=>h.trim()===name);
        const iId=idx("고유번호"), iName=idx("시설명"), iAddr=idx("구분주소"), iGrp=idx("군집"), iLat=idx("위도"), iLng=idx("경도"), iRoute=idx("경로");
        $("#selBody").innerHTML=''; selectedIds.clear();
        for(const line of lines){
          const t=line.split(/\\t|,/);
          const id=t[iId]; const base=rowsById.get(String(id))||{};
          addToSel({id:String(id||""), name:t[iName]??base.name??"", addr:t[iAddr]??base.addr??"", grp:t[iGrp]??base.grp??"", lat:parseFloat(t[iLat]??base.lat), lng:parseFloat(t[iLng]??base.lng)});
          const last=$("#selBody tr:last-child input.routeOrder"); if(last) last.value = t[iRoute]||"";
        }
      }
      alert("선택목록이 로드되었습니다.");
      e.target.value='';
    });

    // left width drag
    (function(){
      let dragging=false,sx,sw;
      $("#gut").addEventListener('mousedown',e=>{dragging=true;sx=e.clientX;sw=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--side-w'))||380; document.body.style.cursor='col-resize'; e.preventDefault();});
      window.addEventListener('mousemove',e=>{if(!dragging) return; const w=Math.min(640,Math.max(0, sw+(e.clientX-sx))); setVar('--side-w',w+'px'); $("#lhs").style.display = (w===0?'none':'block'); map.invalidateSize();});
      window.addEventListener('mouseup',()=>{if(dragging){dragging=false; document.body.style.cursor='';}});
    })();

    // PDF
    $("#btnPDFMap").onclick=async()=>{
      const {jsPDF}=window.jspdf; if(!jsPDF){alert("jsPDF 로더 오류"); return;}
      const mapEl=$("#map");
      const scale=parseInt($("#capScale").value)||2;
      const canvas=await html2canvas(mapEl,{scale, useCORS:true, backgroundColor:"#ffffff"});
      const pdf=new jsPDF({orientation:'l',unit:'mm',format:'a4',compress:true});
      const pageW=pdf.internal.pageSize.getWidth(), pageH=pdf.internal.pageSize.getHeight();
      const mg=5; const maxW=pageW-mg*2, maxH=pageH-mg*2, ratio=canvas.width/canvas.height;
      let w=maxW, h=maxW/ratio; if(h>maxH){h=maxH; w=maxH*ratio;}
      const x=(pageW-w)/2, y=(pageH-h)/2;
      pdf.addImage(canvas.toDataURL("image/jpeg",0.92),"JPEG",x,y,w,h,"","FAST");
      pdf.save("지도.pdf");
    };
    $("#btnPDFScreen").onclick=async()=>{
      const {jsPDF}=window.jspdf; if(!jsPDF){alert("jsPDF 로더 오류"); return;}
      const canvas=await html2canvas(document.body,{scale:parseInt($("#capScale").value)||2,useCORS:true,backgroundColor:"#ffffff"});
      const pdf=new jsPDF({orientation:($("#capOrient").value==='l'?'l':'p'),unit:'mm',format:'a4',compress:true});
      const pageW=pdf.internal.pageSize.getWidth(), pageH=pdf.internal.pageSize.getHeight();
      const mg=(parseFloat($("#capMargin").value)||0.7)*10;
      const maxW=pageW-mg*2, maxH=pageH-mg*2, ratio=canvas.width/canvas.height;
      let w=maxW, h=maxW/ratio; if(h>maxH){h=maxH; w=maxH*ratio;}
      const x=(pageW-w)/2, y=(pageH-h)/2;
      pdf.addImage(canvas.toDataURL("image/jpeg",0.92),"JPEG",x,y,w,h,"","FAST");
      pdf.save("현재화면_캡처.pdf");
    };
    $("#toggleBW").addEventListener('change',e=>{ document.body.classList.toggle('bw',e.target.checked); });

    $('#darkToggle').addEventListener('change', e=>{ document.body.classList.toggle('dark', e.target.checked); });
  }

  function updateFontVars(){ setVar('--tbl-font', tblFont+'px'); setVar('--flt-font', fltFont+'px'); setVar('--mk', mk+'px'); }

  function init(){
    setupMap(); bind();
    $("#btnTblUp").onclick=()=>{ tblFont=Math.min(18,++tblFont); updateFontVars(); };
    $("#btnTblDn").onclick=()=>{ tblFont=Math.max(10,--tblFont); updateFontVars(); };
    $("#btnFltUp").onclick=()=>{ fltFont=Math.min(18,++fltFont); updateFontVars(); };
    $("#btnFltDn").onclick=()=>{ fltFont=Math.max(11,--fltFont); updateFontVars(); };
    $("#btnMkUp").onclick =()=>{ mk=Math.min(44,mk+4); updateFontVars(); render(false); };
    $("#btnMkDn").onclick =()=>{ mk=Math.max(20,mk-4); updateFontVars(); render(false); };
  }
  return { init };
})();
</script>
<!-- ==== CLUSTRO PATCH v6 (panel 안정화 + 4변 리사이즈 + 지도차단 + 경로 외 마커 숨김 토글) ==== -->
<style>
  /* 선택목록 패널: 4변 리사이즈 핸들(패널 밖 14~20px 띠) */
  #selPanel{position:absolute; right:16px; bottom:90px; min-width:360px; min-height:220px;}
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}
  /* 지도 상호작용 차단용 실드 */
  #mapShield{position:absolute; inset:0; background:transparent; z-index:5999; display:none}
  /* 경로 외 마커 숨김 적용 시, 숨김 처리를 위한 클래스 */
  .clo-hidden{opacity:0 !important; pointer-events:none !important}
</style>

<div id="mapShield" aria-hidden="true"></div>

<script>
(function(){
  const $ = (q,root=document)=>root.querySelector(q);
  const $$ = (q,root=document)=>Array.from(root.querySelectorAll(q));

  /* -----------------------------------------------------------
   * 1) 선택목록 패널: 튕김 방지(지도 상호작용 차단) + 드래그 + 4변 리사이즈
   * ---------------------------------------------------------*/
  const panel = document.getElementById('selPanel');
  if(panel){
    // 리사이즈 엣지 없으면 생성
    if(!panel.querySelector('.e-left')){
      ['left','right','top','bottom'].forEach(k=>{
        const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
      });
    }

    // 지도 차단 실드
    const map = document.getElementById('map');
    const shield = document.getElementById('mapShield');
    function showShield(){ if(map) shield.style.display='block'; }
    function hideShield(){ shield.style.display='none'; }
    // 패널에 마우스 들어오면 지도 드래그/휠/더블클릭 모두 차단
    function blockMapInteractions(){
      showShield();
      // 패널 내부 스크롤/휠/터치도 전파 차단
      const stop = e=>{ e.preventDefault(); e.stopPropagation(); };
      panel.addEventListener('wheel', stop, {passive:false});
      panel.addEventListener('touchmove', stop, {passive:false});
      panel.__stop = stop;
      // Leaflet 쪽도 추가 안전장치
      if(window.L && L.DomEvent){
        try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
      }
    }
    function unblockMapInteractions(){
      hideShield();
      if(panel.__stop){
        panel.removeEventListener('wheel', panel.__stop, {passive:false});
        panel.removeEventListener('touchmove', panel.__stop, {passive:false});
        panel.__stop=null;
      }
    }
    panel.addEventListener('mouseenter', blockMapInteractions);
    panel.addEventListener('mouseleave', unblockMapInteractions);

    // 드래그(헤더 더블클릭 → 기본 위치 복원)
    const head = panel.querySelector('.head') || panel;
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', e=>{
      // 버튼/입력 위에서는 드래그 시작 안 함
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      const r=panel.getBoundingClientRect();
      dragging=true; panel.classList.add('dragging');
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      panel.style.left=r.left+'px'; panel.style.top=r.top+'px';
      panel.style.right=''; panel.style.bottom='';
      document.body.style.userSelect='none';
      showShield(); // 드래그 중에도 지도 차단
      e.preventDefault();
    });
    window.addEventListener('mousemove', e=>{
      if(!dragging) return;
      panel.style.left = (sl + (e.clientX - sx)) + 'px';
      panel.style.top  = (st + (e.clientY - sy)) + 'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging=false; panel.classList.remove('dragging');
      document.body.style.userSelect='';
      hideShield();
    });
    head.addEventListener('dblclick', ()=>{
      panel.style.width=''; panel.style.height='';
      panel.style.left=''; panel.style.top='';
      panel.style.right='16px'; panel.style.bottom='90px';
    });

    // 4변 리사이즈
    (function edgeResize(){
      const minW=360, minH=220;
      let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0, sl=0, st=0;
      function start(e, which){
        const r=panel.getBoundingClientRect();
        resizing=true; edge=which;
        sx=e.clientX; sy=e.clientY; sw=r.width; sh=r.height; sl=r.left; st=r.top;
        panel.style.left = sl+'px'; panel.style.top = st+'px';
        panel.style.right=''; panel.style.bottom='';
        document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
        showShield();
        e.preventDefault();
      }
      function move(e){
        if(!resizing) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        if(edge==='right'){ panel.style.width = Math.max(minW, sw+dx) + 'px'; }
        if(edge==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
        if(edge==='bottom'){ panel.style.height= Math.max(minH, sh+dy) + 'px'; }
        if(edge==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
      }
      function stop(){
        if(!resizing) return;
        resizing=false; edge=''; document.body.style.cursor=''; hideShield();
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', stop);
      }
      panel.querySelector('.e-left')  .addEventListener('mousedown', e=>{start(e,'left');  window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-right') .addEventListener('mousedown', e=>{start(e,'right'); window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-top')   .addEventListener('mousedown', e=>{start(e,'top');   window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-bottom').addEventListener('mousedown', e=>{start(e,'bottom');window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
    })();
  }

  /* -----------------------------------------------------------
   * 2) 경로 외 마커 숨김 토글(경로 계산 후 라우트에 포함되지 않은 마커를 숨김)
   *    - 표의 첫번째 열(고유번호)을 기준으로 판별
   *    - 라벨이 고유번호가 아닐 때도 동작하도록 마커 DOM에서 숫자 추출 시도
   * ---------------------------------------------------------*/
  // 토글 UI를 경로 섹션 카드에 주입
  (function injectToggle(){
    const host = document.querySelector('#secRoute .card') || document.querySelector('#secRoute');
    if(!host || document.getElementById('toggleHideNonRoute')) return;
    const wrap = document.createElement('div');
    wrap.style.cssText='margin-top:8px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;';
    wrap.innerHTML = `
      <label class="chip" style="user-select:none">
        <input type="checkbox" id="toggleHideNonRoute"> 경로 외 마커 숨김
      </label>
      <span class="small">※ 표의 <b>고유번호</b>를 기준으로 숨김 처리</span>
    `;
    host.appendChild(wrap);
    document.getElementById('toggleHideNonRoute').addEventListener('change', applyRouteFilter);
  })();

  // 현재 표의 "경로 순번"이 들어간 행의 고유번호 집합 구하기
  function currentRouteIdSet(){
    const set = new Set();
    $$('#selBody tr').forEach(tr=>{
      const id = (tr.querySelector('td')?.innerText||'').trim();
      const ord = tr.querySelector('input.routeOrder')?.value?.trim() || '';
      if(id && ord) set.add(String(id));
    });
    return set;
  }

  // 마커 DOM에서 숫자형 아이디 추출 (라벨이 이름/주소여도 숫자 묶음이 있으면 시도)
  function readMarkerIdFromEl(el){
    if(!el) return '';
    // divIcon의 첫번째 자식이 mk* 박스
    const box = el.querySelector('.mk, .mk-circle, .mk-bubble, .mk-tag') || el.firstElementChild;
    const t = (box?.textContent||'').trim();
    // "1234" 또는 "1234 · ..." 등에서 숫자만 추출
    const m = t.match(/\d{2,}/);  // 최소 2자리
    return m ? m[0] : t;
  }

  function iterMarkerBoxes(){
    // Leaflet divIcon 마커 컨테이너
    return $$('.leaflet-marker-pane > div');
  }

  function applyRouteFilter(){
    const on = document.getElementById('toggleHideNonRoute')?.checked;
    if(!on){
      iterMarkerBoxes().forEach(el=>el.classList.remove('clo-hidden'));
      return;
    }
    const routeIds = currentRouteIdSet();
    if(routeIds.size===0){
      // 순번이 없다면 숨김 해제
      iterMarkerBoxes().forEach(el=>el.classList.remove('clo-hidden'));
      return;
    }
    iterMarkerBoxes().forEach(el=>{
      const id = readMarkerIdFromEl(el);
      if(routeIds.has(String(id))) el.classList.remove('clo-hidden');
      else el.classList.add('clo-hidden');
    });
  }

  // 경로 계산/초기화 버튼에 연동 (존재하는 경우에만)
  (function hookRouteButtons(){
    const btnCalc  = document.getElementById('btnRoute');
    const btnClear = document.getElementById('btnRouteClear');
    if(btnCalc){
      btnCalc.addEventListener('click', ()=>{
        // 계산 후 DOM 업데이트 타이밍 고려해 약간 늦게 적용
        setTimeout(applyRouteFilter, 50);
      }, {capture:true});
    }
    if(btnClear){
      btnClear.addEventListener('click', ()=>{
        setTimeout(()=>{ 
          // 표 순번/경로 지우면 마커 전부 다시 보이게
          const tog = document.getElementById('toggleHideNonRoute'); 
          if(tog) tog.checked = false;
          applyRouteFilter();
        }, 0);
      }, {capture:true});
    }
    // 표 편집/삭제 등에도 반응
    const selBody = document.getElementById('selBody');
    if(selBody){
      selBody.addEventListener('input', e=>{
        if(e.target.classList.contains('routeOrder')) applyRouteFilter();
      });
      selBody.addEventListener('click', e=>{
        if(e.target.classList.contains('btn-del')) setTimeout(applyRouteFilter, 0);
      });
    }
  })();

  // 지도가 다시 그려질 때(필터/리렌더 후)도 한 번 더 적용되도록 MutationObserver
  (function observeMarkerPane(){
    const pane = document.querySelector('.leaflet-marker-pane');
    if(!pane || window.__cloMO) return;
    const mo = new MutationObserver(()=>{ 
      // 마커 DOM이 바뀌면 현재 토글 상태로 다시 적용
      if(document.getElementById('toggleHideNonRoute')?.checked) applyRouteFilter();
    });
    mo.observe(pane, {childList:true, subtree:true});
    window.__cloMO = mo;
  })();

  /*
   * 알고리즘 사용법 툴팁
   * routeMethod 또는 engine 드롭다운에 마우스를 올리면 해당 알고리즘의 설명을 보여줍니다.
   */
  (function setupAlgoTooltip(){
    // 설명 사전
    const tips = {
      // 내장 및 최근점 알고리즘: 인접 시설을 빠르게 방문하는 근사 방식입니다.
      'nn2opt':'내장 알고리즘: 가까운 시설을 먼저 방문한 다음 경로를 조금씩 바꿔 거리를 줄이는 방식입니다.',
      'nn':'최근점 알고리즘: 현재 위치에서 가장 가까운 시설부터 차례대로 이동하는 단순한 방법입니다.',
      // 클러스터: 공간을 여러 구역으로 나누어 각 구역 안에서 순서를 찾는 방식입니다.
      'cluster':'클러스터: 가까운 시설들을 여러 구역으로 묶어 각 구역 안에서 최적 순서를 찾습니다. 먼 거리를 한 번에 도는 대신 근처 구역을 집중적으로 돌아봅니다.',
      'hilbert':'힐버트: 지도를 지그재그로 채우는 궤적을 따라 이동합니다. 인접한 시설을 자연스럽게 이어 주어 한 바퀴 크게 도는 구간을 줄입니다.',
      'kmeans':'K-평균: 전체 시설을 몇 개의 그룹으로 나눈 후 그룹별로 경로를 계산합니다. 각 그룹을 순서대로 방문해 작업 구역을 뭉쳐서 처리할 때 유용합니다.',
      'builtin':'내장: 가까운 시설부터 2-opt로 개선하는 기본 알고리즘입니다.',
      'osrm':'OSRM: 인터넷 OSRM 서버를 사용해 실제 도로를 따라 가장 짧은 경로를 찾습니다.'
    };
    // 툴팁 요소 생성
    const tip=document.createElement('div');
    tip.id='algoTooltip';
    tip.style.cssText='position:absolute; z-index:10000; background:#fefce8; border:1px solid #facc15; padding:6px 8px; border-radius:6px; font-size:12px; color:#78350f; display:none; max-width:260px; box-shadow:0 2px 6px rgba(0,0,0,0.15);';
    document.body.appendChild(tip);
    function show(e){
      const val = e.target.value;
      const msg = tips[val];
      if(!msg){ tip.style.display='none'; return; }
      tip.textContent = msg;
      const rect = e.target.getBoundingClientRect();
      tip.style.left = (rect.left + window.scrollX) + 'px';
      tip.style.top = (rect.bottom + window.scrollY + 4) + 'px';
      tip.style.display = 'block';
    }
    function hide(){ tip.style.display = 'none'; }
    ['routeMethod','engine'].forEach(id=>{
      const el=document.getElementById(id);
      if(!el) return;
      el.addEventListener('mouseenter', show);
      el.addEventListener('mousemove', show);
      el.addEventListener('mouseleave', hide);
      el.addEventListener('change', show);
    });
  })();

})();
</script>
<!-- ==== CLUSTRO PATCH v7 (Panel fixed overlay + Hard reset all + 경로 외 마커 숨김) ==== -->
<style>
  /* 선택목록 패널 - fixed 고정 + 4변 리사이즈 핸들 */
  #selPanel{
    position:fixed !important;
    right:16px; bottom:90px;
    min-width:360px; min-height:220px;
    will-change:left, top, width, height, transform;
    transform:translateZ(0);
    z-index:6000;
  }
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 지도 차단 실드(패널 hover/drag/resize 동안) */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}

  /* 경로 외 마커 숨김 때 사용 */
  .clo-hidden{opacity:0 !important; pointer-events:none !important}
</style>

<!-- 지도 이벤트 차단용 투명 실드 (한 번만 선언!) -->
<div id="mapShield" aria-hidden="true"></div>

<script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  /* A. 선택목록 패널: 튕김 방지 + 드래그 + 4변 리사이즈 */
  (function setupPanel(){
    const panel = $('#selPanel'); const shield = $('#mapShield');
    if(!panel || !shield) return;

    // 엣지 핸들 없으면 생성
    if(!panel.querySelector('.e-left')){
      ['left','right','top','bottom'].forEach(k=>{
        const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
      });
    }

    const stop=(e)=>{ e.preventDefault(); e.stopPropagation(); };
    const showShield=()=>{ shield.style.display='block'; };
    const hideShield=()=>{ shield.style.display='none'; };

    // 패널 hover 시 지도 상호작용 차단
    panel.addEventListener('mouseenter', ()=>{
      showShield();
      panel.addEventListener('wheel', stop, {passive:false});
      panel.addEventListener('touchmove', stop, {passive:false});
      if(window.L && L.DomEvent){
        try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
      }
    });
    panel.addEventListener('mouseleave', ()=>{
      hideShield();
      panel.removeEventListener('wheel', stop, {passive:false});
      panel.removeEventListener('touchmove', stop, {passive:false});
    });

    // 드래그 (헤더 더블클릭 → 기본 위치 복원)
    const head = panel.querySelector('.head') || panel;
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', (e)=>{
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      const r=panel.getBoundingClientRect();
      dragging=true; panel.classList.add('dragging');
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      panel.style.left=sl+'px'; panel.style.top=st+'px';
      panel.style.right=''; panel.style.bottom='';
      document.body.style.userSelect='none';
      showShield();
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      panel.style.left=(sl+(e.clientX-sx))+'px';
      panel.style.top =(st+(e.clientY-sy))+'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging=false; panel.classList.remove('dragging');
      document.body.style.userSelect='';
      hideShield();
    });
    head.addEventListener('dblclick', ()=>{
      panel.style.width=''; panel.style.height='';
      panel.style.left='';  panel.style.top='';
      panel.style.right='16px'; panel.style.bottom='90px';
    });

    // 4변 리사이즈
    (function edgeResize(){
      const minW=360, minH=220;
      let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0, sl=0, st=0;
      function start(e, which){
        const r=panel.getBoundingClientRect();
        resizing=true; edge=which;
        sx=e.clientX; sy=e.clientY; sw=r.width; sh=r.height; sl=r.left; st=r.top;
        panel.style.left=sl+'px'; panel.style.top=st+'px';
        panel.style.right=''; panel.style.bottom='';
        document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
        showShield(); e.preventDefault();
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', stop);
      }
      function move(e){
        if(!resizing) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        if(edge==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
        if(edge==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
        if(edge==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
        if(edge==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
      }
      function stop(){
        if(!resizing) return;
        resizing=false; edge=''; document.body.style.cursor=''; hideShield();
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', stop);
      }
      panel.querySelector('.e-left')  .addEventListener('mousedown', e=>start(e,'left'));
      panel.querySelector('.e-right') .addEventListener('mousedown', e=>start(e,'right'));
      panel.querySelector('.e-top')   .addEventListener('mousedown', e=>start(e,'top'));
      panel.querySelector('.e-bottom').addEventListener('mousedown', e=>start(e,'bottom'));
    })();
  })();

  /* B. 경로 외 마커 숨김 토글 주입 + 적용 */
  (function hideNonRoutePatch(){
    // UI 주입(없을 때만)
    const host = document.querySelector('#secRoute .card') || document.querySelector('#secRoute');
    if(host && !document.getElementById('toggleHideNonRoute')){
      const wrap=document.createElement('div');
      wrap.style.cssText='margin-top:8px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;';
      wrap.innerHTML='<label class="chip" style="user-select:none"><input type="checkbox" id="toggleHideNonRoute"> 경로 외 마커 숨김</label><span class="small">※ 표의 <b>고유번호</b>와 경로순번 기준</span>';
      host.appendChild(wrap);
    }

    const getRouteIdSet=()=>{
      const s=new Set();
      $$('#selBody tr').forEach(tr=>{
        const id=(tr.querySelector('td')?.innerText||'').trim();
        const ord=tr.querySelector('input.routeOrder')?.value?.trim();
        if(id && ord) s.add(String(id));
      });
      return s;
    };
    const markerBoxes=()=>$$('.leaflet-marker-pane > div');
    const readIdFromEl=(el)=>{
      const box=el.querySelector('.mk,.mk-circle,.mk-bubble,.mk-tag')||el.firstElementChild;
      const t=(box?.textContent||'').trim();
      const m=t.match(/\d{2,}/); // 숫자 라벨 우선
      return m?m[0]:t;
    };
    const apply=()=>{
      const tog=$('#toggleHideNonRoute'); if(!tog){return;}
      if(!tog.checked){ markerBoxes().forEach(el=>el.classList.remove('clo-hidden')); return; }
      const ids=getRouteIdSet();
      if(!ids.size){ markerBoxes().forEach(el=>el.classList.remove('clo-hidden')); return; }
      markerBoxes().forEach(el=>{
        const id=readIdFromEl(el);
        if(ids.has(String(id))) el.classList.remove('clo-hidden');
        else el.classList.add('clo-hidden');
      });
    };

    // 바인딩
    $('#toggleHideNonRoute')?.addEventListener('change', apply);
    $('#selBody')?.addEventListener('input', e=>{ if(e.target.classList.contains('routeOrder')) apply(); });
    $('#selBody')?.addEventListener('click', e=>{ if(e.target.classList.contains('btn-del')) setTimeout(apply,0); });

    // 경로 계산 직후/리렌더 후 재적용
    $('#btnRoute')?.addEventListener('click', ()=>setTimeout(apply,50), {capture:true});
    const pane=document.querySelector('.leaflet-marker-pane');
    if(pane && !window.__cloMO){
      const mo=new MutationObserver(()=>{ if($('#toggleHideNonRoute')?.checked) apply(); });
      mo.observe(pane,{childList:true,subtree:true}); window.__cloMO=mo;
    }

    // 하드 초기화에 연동
    window.__clo_unhideAll=()=>{
      const tog=$('#toggleHideNonRoute'); if(tog) tog.checked=false;
      document.querySelectorAll('.clo-hidden').forEach(el=>el.classList.remove('clo-hidden'));
    };
  })();

  /* C. 하드 초기화: 경로선/선택표시/숨김토글까지 싹 초기화 */
  (function bindHardReset(){
    function hardResetAll(){
      try{
        // 1) Leaflet 경로 오버레이 제거
        document.querySelectorAll('.leaflet-overlay-pane svg path, .leaflet-overlay-pane svg polyline')
          .forEach(el=>{ try{ el.remove(); }catch(_){} });
        // 2) 경로 순번 입력칸 비움
        document.querySelectorAll('input.routeOrder').forEach(i=>i.value='');
        // 3) 마커 선택 강조 해제
        document.querySelectorAll('.mk-bubble.sel, .mk-circle.sel, .mk-tag.sel')
          .forEach(el=>el.classList.remove('sel'));
        // 4) 경로 외 숨김 해제
        window.__clo_unhideAll && window.__clo_unhideAll();
        // 5) 상태 텍스트 리셋
        const ab=$('#abInfo'); if(ab) ab.textContent='A/B: -';
        const rs=$('#routeStat'); if(rs) rs.textContent='거리: - / 시간: -';
      }catch(e){ console.warn('hardResetAll', e); }
    }
    // 좌측 섹션 초기화, 상단 초기화에 바인딩
    (function(){
      const left = document.getElementById('btnABReset') ||
        Array.from(document.querySelectorAll('#secRoute button')).find(b=>b.textContent.trim()==='초기화');
      if(left) left.addEventListener('click', ()=>setTimeout(hardResetAll,0), {capture:true});
      const top = document.getElementById('btnRouteClear') ||
        Array.from(document.querySelectorAll('button')).find(b=>b.textContent.trim()==='초기화');
      if(top) top.addEventListener('click',  ()=>setTimeout(hardResetAll,0), {capture:true});
    })();
  })();

  /* E. Move font/marker adjustment buttons into the settings block and wire auto‑recalculation toggle */
  (function setupSettingsPanel(){
    const block=document.getElementById('settingsBlock');
    if(block){
      const ids=['btnTblUp','btnTblDn','btnFltUp','btnFltDn','btnMkUp','btnMkDn'];
      ids.forEach(id=>{
        const el=document.getElementById(id);
        if(el){ el.style.display=''; block.appendChild(el); }
      });
    }
    // auto recalc: when route order inputs change or rows are deleted, recompute route automatically if toggle is on
    const tog=document.getElementById('toggleAutoRecalc');
    const body=document.getElementById('selBody');
    if(tog && body){
      body.addEventListener('input', e=>{
        if(e.target.classList.contains('routeOrder') && tog.checked){ computeRoute(); }
      });
      body.addEventListener('click', e=>{
        if(e.target.classList.contains('btn-del') && tog.checked){ setTimeout(()=>computeRoute(),0); }
      });
    }
  })();

  /* D. 경로 헤더 정렬: 클릭 시 오름/내림차순 토글 및 경로 자동 재계산 */
  (function initRouteHeaderSort(){
    const header = document.getElementById('routeHeader');
    if(!header) return;
    let ascending = true;
    header.style.cursor = 'pointer';
    header.addEventListener('click', ()=>{
      const body = document.getElementById('selBody');
      if(!body) return;
      const rows = Array.from(body.querySelectorAll('tr'));
      rows.sort((a,b)=>{
        const aVal = parseInt(a.querySelector('input.routeOrder')?.value || '0');
        const bVal = parseInt(b.querySelector('input.routeOrder')?.value || '0');
        return ascending ? (aVal - bVal) : (bVal - aVal);
      });
      rows.forEach(r=>body.appendChild(r));
      ascending = !ascending;
      // Trigger route recomputation to reflect new order
      if(rows.length>=2) computeRoute();
    });
  })();

})();
</script>
<!-- ==== /CLUSTRO PATCH v7 ==== -->
<!-- ==== CLUSTRO PATCH v8 (panel drag/resize 안정화 + 사이즈 고정 + 임계값) ==== -->
<style>
  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }
</style>

<script>
(function(){
  const panel = document.getElementById('selPanel');
  if(!panel || panel.dataset.v8Applied) return;
  panel.dataset.v8Applied = '1';

  const head = panel.querySelector('.head') || panel;
  const shield = document.getElementById('mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ── A. 드래그: 사이즈 고정 + 임계값(4px) + 포인터 캡처 ───────────────── */
  let dragging = false;
  let armingDrag = false;  // 임계값 돌파 전 준비상태
  let sx=0, sy=0, sl=0, st=0, startW=0, startH=0;
  const THRESH = 4;

  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    // v7 기존 핸들러보다 먼저 처리하고 전파 차단(충돌 방지)
    e.stopImmediatePropagation();
    e.preventDefault();

    const r = panel.getBoundingClientRect();
    // 드래그 중 크기 흔들림 방지: 현재 크기를 고정
    startW = r.width; startH = r.height;
    panel.style.width  = startW + 'px';
    panel.style.height = startH + 'px';

    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
    armingDrag = true; dragging = false;

    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect');
    showShield();
  }
  function onHeadMove(e){
    if(!armingDrag && !dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    if(!dragging){
      if(Math.abs(dx) > THRESH || Math.abs(dy) > THRESH){
        dragging = true; armingDrag = false;
        // 위치 기준을 left/top으로 고정
        const r = panel.getBoundingClientRect();
        panel.style.left = r.left + 'px';
        panel.style.top  = r.top  + 'px';
        panel.style.right=''; panel.style.bottom='';
      } else {
        // 임계 전에는 기존 핸들러로 넘어가지 않도록 계속 캡처
        e.stopImmediatePropagation();
        return;
      }
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    panel.style.left = (sl + dx) + 'px';
    panel.style.top  = (st + dy) + 'px';
  }
  function onHeadUp(e){
    if(!(armingDrag || dragging)) return;
    e.stopImmediatePropagation();
    armingDrag = false; dragging = false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect');
    hideShield();
  }

  /* 포인터 이벤트(캡처 단계)로 등록 → 기존 v7 핸들러보다 먼저 동작 */
  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});

  /* 더블클릭 기본 위치 복원 시에도 크기 고정 해제 대신 현재 값 유지 */
  head.addEventListener('dblclick', (e)=>{
    // v7의 복원 로직이 실행되더라도 width/height 흔들림 방지를 위해 그대로 유지
    // 필요시 아래 두 줄을 주석 해제해 원래 자동크기로 되돌릴 수 있음
    // panel.style.width=''; panel.style.height='';
  }, {capture:true});

  /* ── B. 4변 리사이즈(좌/상 무제한, 최소 120px만 유지) ─────────────────── */
  const minW=120, minH=120;

  function startResize(e, which){
    e.stopImmediatePropagation();
    e.preventDefault();

    const r = panel.getBoundingClientRect();
    startW=r.width; startH=r.height; sl=r.left; st=r.top;
    sx=e.clientX; sy=e.clientY;

    panel.style.left = sl+'px'; panel.style.top = st+'px';
    panel.style.right=''; panel.style.bottom='';

    document.body.style.cursor = (which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx = ev.clientX - sx, dy = ev.clientY - sy;
      if(which==='right'){ panel.style.width  = Math.max(minW, startW+dx) + 'px'; }
      if(which==='left' ){ const w=Math.max(minW, startW-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){panel.style.height = Math.max(minH, startH+dy) + 'px'; }
      if(which==='top'   ){ const h=Math.max(minH, startH-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation(); 
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor='';
      document.body.classList.remove('clo-noselect');
      hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }

  // 엣지 핸들에 v8 리사이즈 바인딩(캡처 단계)
  const el = panel.querySelector('.e-left');
  const er = panel.querySelector('.e-right');
  const et = panel.querySelector('.e-top');
  const eb = panel.querySelector('.e-bottom');
  if(el) el.addEventListener('pointerdown', e=>startResize(e,'left'),  {capture:true});
  if(er) er.addEventListener('pointerdown', e=>startResize(e,'right'), {capture:true});
  if(et) et.addEventListener('pointerdown', e=>startResize(e,'top'),   {capture:true});
  if(eb) eb.addEventListener('pointerdown', e=>startResize(e,'bottom'),{capture:true});

})();
</script>
<!-- ==== /CLUSTRO PATCH v8 ==== -->
<!-- ==== CLUSTRO PATCH v9 (panel pin + safe drag/resize + hover ghost fix) ==== -->
<style>
  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }
  /* 선택목록 패널 기본 고정값(있어도 무방) */
  #selPanel{
    position:fixed !important;
    min-width:360px; min-height:220px;
    z-index:6000; transform:translateZ(0);
  }
  /* 4변 리사이즈 핸들 – 표 바깥 띠 */
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 지도 차단용 투명 실드(없으면 주입됨) */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}
</style>

<div id="mapShield" aria-hidden="true"></div>

<script>
(function(){
  const panel = document.getElementById('selPanel');
  if(!panel || panel.dataset.cloV9Applied) return;
  panel.dataset.cloV9Applied = '1';

  const head = panel.querySelector('.head') || panel;
  const shield = document.getElementById('mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ── 0) 최초 고정 앵커: right/bottom → left/top 으로 ‘핀’ 고정 ─────────── */
  (function pinPanelOnce(){
    const r = panel.getBoundingClientRect();
    // 이미 사용자가 위치를 만졌다면 건들지 않음
    if(panel.style.left || panel.style.top) return;
    panel.style.left = (r.left || (window.innerWidth - r.width - 16)) + 'px';
    panel.style.top  = (r.top  || (window.innerHeight - r.height - 90)) + 'px';
    panel.style.right = ''; panel.style.bottom = '';
  })();

  // 리사이즈 핸들 없으면 생성
  if(!panel.querySelector('.e-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
    });
  }

  /* ── 1) Hover로는 절대 이동/리사이즈 시작 안 함(오인 방지) ─────────────── */
  const THRESH = 4;                       // 드래그 시작 임계값
  let arming=false, dragging=false;       // 드래그 준비/진행
  let sx=0, sy=0, sl=0, st=0, sw=0, sh=0; // 시작 좌표/패널치수
  const minW=120, minH=120;

  // 지도 이벤트 차단(hover만으로는 패널 이동 안 함)
  const stop = e=>{ e.preventDefault(); e.stopPropagation(); };
  panel.addEventListener('mouseenter', ()=>{
    // hover 때 지도 상호작용만 막는다(패널 이동은 arm 상태 아니면 시작 안 함)
    showShield();
    panel.addEventListener('wheel', stop, {passive:false});
    panel.addEventListener('touchmove', stop, {passive:false});
    if(window.L && L.DomEvent){
      try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
    }
  });
  panel.addEventListener('mouseleave', ()=>{
    if(!dragging) hideShield(); // 드래그/리사이즈 중이 아니라면 해제
    panel.removeEventListener('wheel', stop, {passive:false});
    panel.removeEventListener('touchmove', stop, {passive:false});
  });

  /* ── 2) 드래그: 반드시 pointerdown 이후 4px↑ 이동해야 시작 ─────────────── */
  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    // 기존 핸들러보다 먼저 먹게 하고, hover-ghost 완전 차단
    e.stopImmediatePropagation(); e.preventDefault();

    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    // 이동 중 사이즈 흔들림 방지: 현재 크기를 px로 고정
    panel.style.width = sw+'px'; panel.style.height = sh+'px';
    // 항상 left/top 기준으로 이동
    panel.style.left = sl+'px'; panel.style.top = st+'px'; panel.style.right=''; panel.style.bottom='';

    arming=true; dragging=false;
    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect');
    showShield();
  }
  function onHeadMove(e){
    if(!arming && !dragging) return;
    const dx=e.clientX-sx, dy=e.clientY-sy;
    if(!dragging){
      if(Math.abs(dx)>THRESH || Math.abs(dy)>THRESH){
        dragging=true; arming=false;
      }else{
        e.stopImmediatePropagation(); // 임계 전엔 어떤 이동도 금지
        return;
      }
    }
    e.stopImmediatePropagation(); e.preventDefault();
    panel.style.left = (sl+dx)+'px';
    panel.style.top  = (st+dy)+'px';
  }
  function onHeadUp(e){
    if(!(arming||dragging)) return;
    e.stopImmediatePropagation();
    arming=false; dragging=false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect');
    hideShield();
  }

  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});
  head.addEventListener('dblclick', (e)=>{
    // 원위치로 되돌리고 싶다면 아래 주석 해제
    // panel.style.width=''; panel.style.height='';
    // panel.style.left=''; panel.style.top=''; panel.style.right='16px'; panel.style.bottom='90px';
  }, {capture:true});

  /* ── 3) 4변 리사이즈(좌/상 무제한), 드래그와 동일한 보호장치 ───────────── */
  function startResize(e, which){
    e.stopImmediatePropagation(); e.preventDefault();
    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';
    document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx=ev.clientX-sx, dy=ev.clientY-sy;
      if(which==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
      if(which==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
      if(which==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation();
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor='';
      document.body.classList.remove('clo-noselect');
      hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }
  const el=panel.querySelector('.e-left'), er=panel.querySelector('.e-right'),
        et=panel.querySelector('.e-top'),  eb=panel.querySelector('.e-bottom');
  if(el) el.addEventListener('pointerdown', e=>startResize(e,'left'),  {capture:true});
  if(er) er.addEventListener('pointerdown', e=>startResize(e,'right'), {capture:true});
  if(et) et.addEventListener('pointerdown', e=>startResize(e,'top'),   {capture:true});
  if(eb) eb.addEventListener('pointerdown', e=>startResize(e,'bottom'),{capture:true});

})();
</script>
<!-- ==== /CLUSTRO PATCH v9 ==== -->
<!-- ==== CLUSTRO PATCH v10 (panel center-on-first-show + improved resize + table buttons) ==== -->
<style>
  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }

  /* 패널 고정 및 리사이즈 핸들(바깥) */
  #selPanel{
    position:fixed !important;
    min-width:360px; min-height:220px;
    z-index:6000; transform:translateZ(0);
  }
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 안쪽 얇은 리사이즈 그립(핸들 맞추기 어렵다는 피드백 반영) */
  #selPanel .grip{position:absolute;background:transparent;pointer-events:auto}
  #selPanel .g-left{left:0; top:0; width:8px; height:100%; cursor:ew-resize}
  #selPanel .g-right{right:0; top:0; width:8px; height:100%; cursor:ew-resize}
  #selPanel .g-top{top:0; left:0; height:8px; width:100%; cursor:ns-resize}
  #selPanel .g-bottom{bottom:0; left:0; height:8px; width:100%; cursor:ns-resize}

  /* 지도 차단 실드 */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}
</style>

<div id="mapShield" aria-hidden="true"></div>

<script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  const panel = $('#selPanel'); if(!panel || panel.dataset.v10Applied) return;
  panel.dataset.v10Applied='1';

  const head   = panel.querySelector('.head') || panel;
  const shield = $('#mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ─────────────────────────────────────────────────────────
   * 0) 최초 표시 시 화면 정중앙 배치 (처음 1회)
   *    - 패널이 display:block 되거나, 선택목록에 첫 행이 추가되면 센터링
   * ───────────────────────────────────────────────────────── */
  function centerPanel(){
    const r = panel.getBoundingClientRect();
    const vw = window.innerWidth, vh = window.innerHeight;
    const w  = Math.max(r.width || 520, 380);
    const h  = Math.max(r.height || 260, 220);
    const left = Math.max(8, Math.round((vw - w)/2));
    const top  = Math.max(8, Math.round((vh - h)/2));
    panel.style.left = left + 'px';
    panel.style.top  = top  + 'px';
    panel.style.right=''; panel.style.bottom='';
  }
  let centeredOnce=false;

  // 패널 display 변화 감지
  const moPanel = new MutationObserver(()=>{
    const disp = getComputedStyle(panel).display;
    if(!centeredOnce && disp!=='none'){
      centerPanel(); centeredOnce=true;
    }
  });
  moPanel.observe(panel,{attributes:true,attributeFilter:['style','class']});

  // 선택목록 첫 행 추가 시에도 센터링 (초기 사용 흐름 보완)
  const selBody = $('#selBody');
  if(selBody){
    const moBody = new MutationObserver(()=>{
      if(!centeredOnce && selBody.children.length>0){
        // 패널이 숨겨져 있다면 열어주기
        if(getComputedStyle(panel).display==='none') panel.style.display='block';
        centerPanel(); centeredOnce=true;
      }
    });
    moBody.observe(selBody,{childList:true});
  }

  /* ─────────────────────────────────────────────────────────
   * 1) 리사이즈: 바깥 핸들 + 안쪽 얇은 그립 모두 지원
   *    상/하/좌/우 무제한(최소 120px) · 드래그와 동일한 실드/노셀렉트
   * ───────────────────────────────────────────────────────── */
  // 바깥 핸들 보강
  if(!panel.querySelector('.e-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
    });
  }
  // 안쪽 그립 추가
  if(!panel.querySelector('.g-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='grip g-'+k; panel.appendChild(d);
    });
  }

  const minW=120, minH=120;
  function startResize(e, which){
    e.stopImmediatePropagation(); e.preventDefault();
    const r=panel.getBoundingClientRect();
    let sx=e.clientX, sy=e.clientY, sl=r.left, st=r.top, sw=r.width, sh=r.height;

    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';
    document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx=ev.clientX-sx, dy=ev.clientY-sy;
      if(which==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
      if(which==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
      if(which==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation();
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor=''; document.body.classList.remove('clo-noselect'); hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }
  ['.e-left','.e-right','.e-top','.e-bottom','.g-left','.g-right','.g-top','.g-bottom'].forEach(sel=>{
    const el=panel.querySelector(sel); if(!el) return;
    const side = /left/.test(sel)?'left':/right/.test(sel)?'right':/top/.test(sel)?'top':'bottom';
    el.addEventListener('pointerdown', e=>startResize(e, side), {capture:true});
  });

  /* ─────────────────────────────────────────────────────────
   * 2) 드래그: hover-ghost 방지, 임계값 4px, 포인터캡처, 사이즈 고정
   * ───────────────────────────────────────────────────────── */
  const THRESH=4;
  let arming=false, dragging=false;
  let sx=0, sy=0, sl=0, st=0, sw=0, sh=0;

  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    e.stopImmediatePropagation(); e.preventDefault();

    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    panel.style.width=sw+'px'; panel.style.height=sh+'px';
    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';

    arming=true; dragging=false;
    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect'); showShield();
  }
  function onHeadMove(e){
    if(!arming && !dragging) return;
    const dx=e.clientX-sx, dy=e.clientY-sy;
    if(!dragging){
      if(Math.abs(dx)>THRESH || Math.abs(dy)>THRESH){ dragging=true; arming=false; }
      else{ e.stopImmediatePropagation(); return; }
    }
    e.stopImmediatePropagation(); e.preventDefault();
    panel.style.left=(sl+dx)+'px';
    panel.style.top =(st+dy)+'px';
  }
  function onHeadUp(e){
    if(!(arming||dragging)) return;
    e.stopImmediatePropagation();
    arming=false; dragging=false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect'); hideShield();
  }
  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});

  /* ─────────────────────────────────────────────────────────
   * 3) 표 버튼(비우기/TSV/XLSX) 다시 바인딩
   * ───────────────────────────────────────────────────────── */
  function bindTableButtons(){
    const body = $('#selBody'); if(!body) return;

    // 표 비우기
    const bClear = $('#btnClearSel');
    if(bClear && !bClear.dataset.bound){
      bClear.dataset.bound='1';
      bClear.addEventListener('click', ()=>{
        body.innerHTML='';
        // 빨간 선택 표시 해제
        $$('.mk-bubble.sel,.mk-circle.sel,.mk-tag.sel').forEach(el=>el.classList.remove('sel'));
      }, {capture:true});
    }

    // TSV 복사
    const bTSV = $('#btnCopyTSV');
    if(bTSV && !bTSV.dataset.bound){
      bTSV.dataset.bound='1';
      bTSV.addEventListener('click', async ()=>{
        const headRow = ["고유번호","시설명","구분주소","군집","위도","경도","경로"];
        const rows=[headRow.join('\t')];
        $$('#selBody tr').forEach(tr=>{
          const t=Array.from(tr.querySelectorAll('td'));
          const route=tr.querySelector('input.routeOrder')?.value||"";
          rows.push([
            t[0]?.innerText||"", t[1]?.innerText||"", t[2]?.innerText||"", t[3]?.innerText||"",
            t[4]?.innerText||"", t[5]?.innerText||"", route
          ].join('\t'));
        });
        const txt=rows.join('\n');
        try{ await navigator.clipboard.writeText(txt); alert('TSV가 복사되었습니다.'); }
        catch(_){
          const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove(); alert('TSV가 복사되었습니다.');
        }
      }, {capture:true});
    }

    // XLSX 저장
    const bXLSX = $('#btnSaveXLSX');
    if(bXLSX && !bXLSX.dataset.bound){
      bXLSX.dataset.bound='1';
      bXLSX.addEventListener('click', ()=>{
        if(!window.XLSX){ alert('XLSX 라이브러리가 로드되지 않았습니다.'); return; }
        const arr=[];
        $$('#selBody tr').forEach(tr=>{
          const t=Array.from(tr.querySelectorAll('td'));
          arr.push({
            "고유번호":t[0]?.innerText||"", "시설명":t[1]?.innerText||"", "구분주소":t[2]?.innerText||"",
            "군집":t[3]?.innerText||"", "위도":t[4]?.innerText||"", "경도":t[5]?.innerText||"",
            "경로":tr.querySelector('input.routeOrder')?.value||""
          });
        });
        const ws=XLSX.utils.json_to_sheet(arr);
        const wb=XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb,ws,"선택목록");
        XLSX.writeFile(wb,"선택목록.xlsx");
      }, {capture:true});
    }
  }
  bindTableButtons();

})();
</script>
<!-- ==== /CLUSTRO PATCH v10 ==== -->
<!-- ==== CLUSTRO PATCH v11 (Panel UX polish + unlimited resize + button redesign) ==== -->
<style>
  /* 색 변수 (라이트/다크 공통 토큰) */
  :root{
    --ui-bg: #ffffff; --ui-fg:#111827; --ui-muted:#6b7280; --ui-border:#e5e7eb;
    --ui-bg-soft:#f8fafc;
    --brand:#2563eb; --brand-2:#1d4ed8;
    --okay:#16a34a; --warn:#d97706; --danger:#dc2626;
    --ring: 0 0 0 3px rgba(37,99,235,.25);
  }
  body.dark{
    --ui-bg:#0f172a; --ui-fg:#e5e7eb; --ui-muted:#9ca3af; --ui-border:#243041;
    --ui-bg-soft:#111827;
    --brand:#60a5fa; --brand-2:#3b82f6;
    --okay:#34d399; --warn:#f59e0b; --danger:#f87171;
    --ring: 0 0 0 3px rgba(96,165,250,.25);
  }

  /* 패널: 드래그 앤 드롭을 고정 사이즈로 제한 */
  #selPanel{
    position:fixed !important; right:16px; bottom:90px;
    width:640px !important; height:480px !important;
    max-width:80vw !important; max-height:70vh !important;
    z-index:6000; background:var(--ui-bg); color:var(--ui-fg);
    border:1px solid var(--ui-border);
    box-shadow:0 8px 24px rgba(0,0,0,.10);
    border-radius:12px; overflow:visible !important;
  }
  /* 엣지 핸들 영역(표 조작과 충돌 안나게 바깥쪽에 배치) */
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel .head{
    background:var(--ui-bg-soft); border-bottom:2px solid var(--ui-border);
    border-top-left-radius:12px; border-top-right-radius:12px;
  }

  /* 버튼 리뉴얼(라이트/다크 대응) */
  #selPanel .btn,
  #selPanel button{
    appearance:none; border:1px solid transparent;
    background:var(--ui-bg); color:var(--ui-fg);
    padding:8px 12px; border-radius:10px; font-weight:700;
    line-height:1; cursor:pointer; transition:.15s;
    box-shadow:0 1px 0 rgba(0,0,0,.06);
  }
  /* 각각의 성격 */
  #btnClearSel{ /* 표 비우기 = 경고성 */
    background:linear-gradient(0deg, rgba(249,115,22,.08), rgba(249,115,22,.08));
    border-color:rgba(249,115,22,.25); color:var(--warn);
  }
  #btnCopyTSV{   /* 보조 = 중립 */
    background:linear-gradient(0deg, rgba(107,114,128,.08), rgba(107,114,128,.08));
    border-color:rgba(107,114,128,.25); color:var(--ui-fg);
  }
  #btnSaveXLSX{  /* 주요 = 브랜드 */
    background:linear-gradient(180deg, var(--brand), var(--brand-2));
    color:#fff; border-color:transparent; box-shadow:0 2px 10px rgba(37,99,235,.25);
  }
  /* Hover/Active/Focus */
  #selPanel .btn:hover{ filter:brightness(1.03); transform:translateY(-1px) }
  #selPanel .btn:active{ transform:translateY(0) }
  #selPanel .btn:focus-visible{ outline:none; box-shadow:var(--ring) }

  /* 우측 Del 아이콘 일관화 */
  #selPanel .row-actions .btn-del{
    display:inline-flex; align-items:center; justify-content:center;
    width:28px; height:28px; border-radius:8px;
    background:transparent; border:1px solid var(--ui-border);
    transition:.15s; cursor:pointer;
  }
  #selPanel .row-actions .btn-del:hover{
    background:rgba(220,38,38,.08); border-color:rgba(220,38,38,.35); color:var(--danger);
  }
  
  /* 길찾기 버튼 스타일 */
  #selPanel .row-actions .btn-nav{
    display:inline-flex; align-items:center; justify-content:center;
    width:28px; height:28px; border-radius:8px; margin-left:4px;
    background:transparent; border:1px solid var(--ui-border);
    transition:.15s; cursor:pointer;
    font-size:14px;
  }
  #selPanel .row-actions .btn-nav:hover{
    background:rgba(59,130,246,.08); border-color:rgba(59,130,246,.35); color:var(--c-sky);
  }

  /* 경로 순번 인풋 톤 맞춤 */
  #selPanel input.routeOrder{
    height:28px; border:1px solid var(--ui-border); border-radius:8px;
    padding:0 8px; background:var(--ui-bg); color:var(--ui-fg);
  }
  #selPanel input.routeOrder:focus{ outline:none; box-shadow:var(--ring); border-color:var(--brand) }

  /* 내부 스크롤 컨테이너 상한 해제 */
  #selPanel > div[style*="max-height"]{ max-height:none !important; height:auto !important }

  /* Allow unlimited resizing with constraints to keep panel header accessible */
  #selPanel{ 
    resize:both !important; 
    overflow:auto !important;
    /* Remove size limits for unlimited resizing */
    min-width: 200px !important;
    min-height: 100px !important;
    max-width: none !important;
    max-height: none !important;
  }
</style>

<!-- 지도 차단 실드(중복 방지) -->
<div id="mapShield" aria-hidden="true" style="position:fixed; inset:0; display:none; background:transparent; z-index:5999"></div>

<script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  const panel = $('#selPanel');
  const shield= $('#mapShield');
  if(!panel || panel.dataset.v11Applied) return;
  panel.dataset.v11Applied='1';

  /* ▸ 버튼 동작 보강(혹시 끊겨있을 경우 재바인딩) */
  // TSV 복사
  if($('#btnCopyTSV') && !$('#btnCopyTSV').dataset.bound){
    $('#btnCopyTSV').addEventListener('click', async ()=>{
      const head=["고유번호","시설명","구분주소","군집","위도","경도","경로"];
      const out=[head.join('\t')];
      $$('#selBody tr').forEach(tr=>{
        const t=Array.from(tr.querySelectorAll('td'));
        const route=tr.querySelector('input.routeOrder')?.value||"";
        out.push([t[0]?.innerText||"", t[1]?.innerText||"", t[2]?.innerText||"", t[3]?.innerText||"", t[4]?.innerText||"", t[5]?.innerText||"", route].join('\t'));
      });
      const txt=out.join('\n');
      try{ await navigator.clipboard.writeText(txt); alert("TSV가 복사되었습니다."); }
      catch(e){ const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); alert("TSV가 복사되었습니다."); }
    });
    $('#btnCopyTSV').dataset.bound='1';
  }
  // XLSX 저장
  if($('#btnSaveXLSX') && !$('#btnSaveXLSX').dataset.bound){
    $('#btnSaveXLSX').addEventListener('click', ()=>{
      if(!window.XLSX){ alert('XLSX 라이브러리가 없습니다.'); return; }
      const arr=[];
      $$('#selBody tr').forEach(tr=>{
        const t=Array.from(tr.querySelectorAll('td'));
        arr.push({"고유번호":t[0]?.innerText||"", "시설명":t[1]?.innerText||"", "구분주소":t[2]?.innerText||"", "군집":t[3]?.innerText||"", "위도":t[4]?.innerText||"", "경도":t[5]?.innerText||"", "경로":tr.querySelector('input.routeOrder')?.value||""});
      });
      const ws=XLSX.utils.json_to_sheet(arr);
      const wb=XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb,ws,"선택목록");
      XLSX.writeFile(wb,"선택목록.xlsx");
    });
    $('#btnSaveXLSX').dataset.bound='1';
  }
  // 표 비우기 (선택/경로도 함께 리셋)
  if($('#btnClearSel') && !$('#btnClearSel').dataset.bound){
    $('#btnClearSel').addEventListener('click', ()=>{
      const body=$('#selBody'); if(body) body.innerHTML='';
      (window.selectedIds?.clear?.bind(window.selectedIds) || function(){})();
      // 선택 스타일 해제
      $$('.mk-bubble.sel,.mk-circle.sel,.mk-tag.sel').forEach(el=>el.classList.remove('sel'));
      // 경로 라인 제거
      try{ window.routeLayer && window.routeLayer.clearLayers && window.routeLayer.clearLayers(); }catch(_){}
      // 순번 입력 비우기/상태 리셋
      $$('input.routeOrder').forEach(i=>i.value='');
      const ab=$('#abInfo'); if(ab) ab.textContent='A/B: -';
      const st=$('#routeStat'); if(st) st.textContent='거리: - / 시간: -';
    });
    $('#btnClearSel').dataset.bound='1';
  }

  /* ▸ 드래그/리사이즈(안정화는 이전 v8/v10 유지) – 기본 동작만: 패널 위 hover 시 지도 차단 */
  const stop=(e)=>{ e.preventDefault(); e.stopPropagation(); };
  function showShield(){ shield && (shield.style.display='block'); }
  function hideShield(){ shield && (shield.style.display='none'); }
  panel.addEventListener('mouseenter', ()=>{
    showShield();
    panel.addEventListener('wheel', stop, {passive:false});
    panel.addEventListener('touchmove', stop, {passive:false});
    if(window.L && L?.DomEvent){
      try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
    }
  });
  panel.addEventListener('mouseleave', ()=>{
    hideShield();
    panel.removeEventListener('wheel', stop, {passive:false});
    panel.removeEventListener('touchmove', stop, {passive:false});
  });

  /* ▸ 중앙 초기 위치 보정 + 경계 제한 기능 */
  function constrainPanelToViewport() {
    const vw = window.innerWidth, vh = window.innerHeight;
    const rect = panel.getBoundingClientRect();
    
    // 패널이 뷰포트 경계를 벗어나지 않도록 제한
    const minX = 0;
    const maxX = vw - rect.width;
    const minY = 0; 
    const maxY = vh - rect.height;
    
    const currentX = parseInt(panel.style.left) || rect.left;
    const currentY = parseInt(panel.style.top) || rect.top;
    
    const constrainedX = Math.max(minX, Math.min(maxX, currentX));
    const constrainedY = Math.max(minY, Math.min(maxY, currentY));
    
    if (constrainedX !== currentX || constrainedY !== currentY) {
      panel.style.left = constrainedX + 'px';
      panel.style.top = constrainedY + 'px';
      panel.style.right = '';
      panel.style.bottom = '';
    }
  }

  if(!panel.dataset.centered){
    const vw=window.innerWidth, vh=window.innerHeight;
    const r=panel.getBoundingClientRect();
    panel.style.left = Math.max(16, (vw - r.width)/2) + 'px';
    panel.style.top  = Math.max(16, (vh - r.height)/2) + 'px';
    panel.style.right = ''; panel.style.bottom = '';
    panel.dataset.centered='1';
  }
  
  // 윈도우 리사이즈 시 패널 경계 체크
  window.addEventListener('resize', constrainPanelToViewport, {passive: true});

  /* ▸ 내부 스크롤 컨테이너 상한 재해제(테마가 갱신해버리는 경우 수시 보정) */
  const scroller = Array.from(panel.children).find(el=>/overflow:auto|scroll/i.test(el.style?.overflow||''));
  function unlock(){ if(!scroller) return; scroller.style.maxHeight='none'; scroller.style.height='auto'; }
  unlock(); window.addEventListener('resize', unlock, {passive:true});
})();
</script>

<!-- Enhanced Mobile Touch and Resize Support -->
<script>
(function() {
  'use strict';
  
  const panel = document.getElementById('selPanel');
  if (!panel || panel.dataset.mobileEnhanced) return;
  panel.dataset.mobileEnhanced = '1';
  
  // Mobile/Touch device detection
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const isMobileViewport = () => window.innerWidth <= 768;
  const isTabletViewport = () => window.innerWidth > 768 && window.innerWidth <= 1024;
  
  // Enhanced touch event handling for better mobile experience
  function addTouchSupport() {
    const head = panel.querySelector('.head');
    const edges = panel.querySelectorAll('.edge');
    
    // Prevent scrolling on the panel during interactions
    function preventScroll(e) {
      if (panel.contains(e.target)) {
        e.preventDefault();
      }
    }
    
    // Enhanced drag support with touch events
    let isDragging = false;
    let isResizing = false;
    let startPos = { x: 0, y: 0 };
    let startRect = null;
    let activeEdge = null;
    
    // Universal event handling (mouse, touch, pointer)
    function getEventPos(e) {
      return {
        x: e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0),
        y: e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0)
      };
    }
    
    // Start dragging/resizing
    function startInteraction(e, type, edge = null) {
      const pos = getEventPos(e);
      startPos = pos;
      startRect = panel.getBoundingClientRect();
      
      if (type === 'drag') {
        isDragging = true;
        panel.style.cursor = 'grabbing';
      } else if (type === 'resize') {
        isResizing = true;
        activeEdge = edge;
      }
      
      // Prevent text selection and other default behaviors
      e.preventDefault();
      document.body.style.userSelect = 'none';
      document.body.style.webkitUserSelect = 'none';
      
      // Add event listeners to document for global tracking
      if (isTouchDevice) {
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', endInteraction, { passive: false });
      } else {
        document.addEventListener('mousemove', handleMove, { passive: false });
        document.addEventListener('mouseup', endInteraction, { passive: false });
      }
    }
    
    // Handle movement during drag/resize
    function handleMove(e) {
      if (!isDragging && !isResizing) return;
      
      const pos = getEventPos(e);
      const deltaX = pos.x - startPos.x;
      const deltaY = pos.y - startPos.y;
      
      if (isDragging) {
        // Drag the panel
        const newLeft = Math.max(0, Math.min(window.innerWidth - startRect.width, startRect.left + deltaX));
        const newTop = Math.max(0, Math.min(window.innerHeight - startRect.height, startRect.top + deltaY));
        
        panel.style.left = newLeft + 'px';
        panel.style.top = newTop + 'px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else if (isResizing && activeEdge) {
        // Resize the panel based on active edge
        const minWidth = isMobileViewport() ? 280 : 360;
        const minHeight = isMobileViewport() ? 180 : 220;
        const maxWidth = window.innerWidth - 32;
        const maxHeight = window.innerHeight - 120;
        
        let newWidth = startRect.width;
        let newHeight = startRect.height;
        let newLeft = startRect.left;
        let newTop = startRect.top;
        
        switch (activeEdge) {
          case 'right':
            newWidth = Math.max(minWidth, Math.min(maxWidth, startRect.width + deltaX));
            break;
          case 'left':
            const leftDelta = Math.min(deltaX, startRect.width - minWidth);
            newWidth = Math.max(minWidth, startRect.width - leftDelta);
            newLeft = Math.max(0, startRect.left + leftDelta);
            break;
          case 'bottom':
            newHeight = Math.max(minHeight, Math.min(maxHeight, startRect.height + deltaY));
            break;
          case 'top':
            const topDelta = Math.min(deltaY, startRect.height - minHeight);
            newHeight = Math.max(minHeight, startRect.height - topDelta);
            newTop = Math.max(0, startRect.top + topDelta);
            break;
        }
        
            // Ensure panel header stays within map boundaries
        const mapContainer = document.getElementById('map');
        const mapRect = mapContainer ? mapContainer.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight };
        const headerHeight = 50; // Approximate header height
        
        // Constrain position so header stays within map bounds
        const constrainedLeft = Math.max(mapRect.left, Math.min(mapRect.right - 200, newLeft));
        const constrainedTop = Math.max(mapRect.top, Math.min(mapRect.bottom - headerHeight, newTop));
        
        // Apply new dimensions and position
        panel.style.width = newWidth + 'px';
        panel.style.height = newHeight + 'px';
        panel.style.left = constrainedLeft + 'px';
        panel.style.top = constrainedTop + 'px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      }
      
      e.preventDefault();
    }
    
    // End interaction
    function endInteraction(e) {
      isDragging = false;
      isResizing = false;
      activeEdge = null;
      panel.style.cursor = '';
      
      document.body.style.userSelect = '';
      document.body.style.webkitUserSelect = '';
      
      // Remove event listeners
      if (isTouchDevice) {
        document.removeEventListener('touchmove', handleMove);
        document.removeEventListener('touchend', endInteraction);
      } else {
        document.removeEventListener('mousemove', handleMove);
        document.removeEventListener('mouseup', endInteraction);
      }
    }
    
    // Add touch/mouse event listeners to header (for dragging)
    if (head) {
      if (isTouchDevice) {
        head.addEventListener('touchstart', (e) => {
          if (!e.target.matches('button, input, select, textarea, a')) {
            startInteraction(e, 'drag');
          }
        }, { passive: false });
      } else {
        head.addEventListener('mousedown', (e) => {
          if (!e.target.matches('button, input, select, textarea, a')) {
            startInteraction(e, 'drag');
          }
        });
      }
      
      // Enhanced double-click/tap to center
      let lastTap = 0;
      function handleDoubleTap(e) {
        const now = Date.now();
        if (now - lastTap < 300) {
          e.preventDefault();
          if (window.centerSelectionPanel) {
            window.centerSelectionPanel();
          }
        }
        lastTap = now;
      }
      
      if (isTouchDevice) {
        head.addEventListener('touchend', handleDoubleTap, { passive: false });
      } else {
        head.addEventListener('dblclick', (e) => {
          if (window.centerSelectionPanel) {
            window.centerSelectionPanel();
          }
        });
      }
    }
    
    // Add touch/mouse event listeners to edges (for resizing)
    edges.forEach(edge => {
      const edgeType = edge.className.split(' ').find(cls => cls.startsWith('e-'))?.substring(2);
      if (!edgeType) return;
      
      if (isTouchDevice) {
        edge.addEventListener('touchstart', (e) => {
          startInteraction(e, 'resize', edgeType);
        }, { passive: false });
      } else {
        edge.addEventListener('mousedown', (e) => {
          startInteraction(e, 'resize', edgeType);
        });
      }
    });
  }
  
  // Apply enhanced touch support
  addTouchSupport();
  
  // Window resize handler for responsive adjustments
  function handleWindowResize() {
    if (panel.style.display !== 'block') return;
    
    const rect = panel.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Ensure panel stays within viewport bounds
    let needsAdjustment = false;
    let newLeft = parseFloat(panel.style.left) || rect.left;
    let newTop = parseFloat(panel.style.top) || rect.top;
    let newWidth = parseFloat(panel.style.width) || rect.width;
    let newHeight = parseFloat(panel.style.height) || rect.height;
    
    // Constrain panel to stay within map boundaries
    const mapContainer = document.getElementById('map');
    const mapRect = mapContainer ? mapContainer.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight };
    const headerHeight = 50; // Approximate header height
    
    // Constrain to map viewport with header accessibility
    if (newLeft + newWidth > mapRect.right) {
      newLeft = Math.max(mapRect.left, mapRect.right - newWidth);
      needsAdjustment = true;
    }
    if (newLeft < mapRect.left) {
      newLeft = mapRect.left;
      needsAdjustment = true;
    }
    if (newTop + headerHeight > mapRect.bottom) {
      newTop = Math.max(mapRect.top, mapRect.bottom - headerHeight);
      needsAdjustment = true;
    }
    if (newTop < mapRect.top) {
      newTop = mapRect.top;
      needsAdjustment = true;
    }
    
    // Ensure minimum size based on viewport
    const minWidth = isMobileViewport() ? 280 : 360;
    const minHeight = isMobileViewport() ? 180 : 220;
    const maxWidth = viewportWidth - 32;
    const maxHeight = viewportHeight - 120;
    
    if (newWidth < minWidth || newWidth > maxWidth) {
      newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
      needsAdjustment = true;
    }
    if (newHeight < minHeight || newHeight > maxHeight) {
      newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
      needsAdjustment = true;
    }
    
    if (needsAdjustment) {
      panel.style.left = newLeft + 'px';
      panel.style.top = newTop + 'px';
      panel.style.width = newWidth + 'px';
      panel.style.height = newHeight + 'px';
      panel.style.right = 'auto';
      panel.style.bottom = 'auto';
    }
  }
  
  // Debounce window resize events
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(handleWindowResize, 100);
  }, { passive: true });
  
  // Initial setup
  handleWindowResize();
})();
</script>
<!-- ==== /CLUSTRO PATCH v11 ==== -->
</body>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js').catch(console.warn);
  });
}
</script>

</html>
